// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_protocol_2eproto__INCLUDED
#define PROTOBUF_protocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pool {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protocol_2eproto();
void protobuf_AssignDesc_protocol_2eproto();
void protobuf_ShutdownFile_protocol_2eproto();

class Block;
class Signal;
class ClientStats;
class Share;
class Request;
class ServerInfo;
class Work;
class Reply;
class ReqStats;
class ServerStats;
class Data;

enum Signal_Type {
  Signal_Type_NEWBLOCK = 1,
  Signal_Type_SHUTDOWN = 2
};
bool Signal_Type_IsValid(int value);
const Signal_Type Signal_Type_Type_MIN = Signal_Type_NEWBLOCK;
const Signal_Type Signal_Type_Type_MAX = Signal_Type_SHUTDOWN;
const int Signal_Type_Type_ARRAYSIZE = Signal_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signal_Type_descriptor();
inline const ::std::string& Signal_Type_Name(Signal_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signal_Type_descriptor(), value);
}
inline bool Signal_Type_Parse(
    const ::std::string& name, Signal_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signal_Type>(
    Signal_Type_descriptor(), name, value);
}
enum Request_Type {
  Request_Type_NONE = 0,
  Request_Type_CONNECT = 1,
  Request_Type_GETWORK = 2,
  Request_Type_SHARE = 3,
  Request_Type_STATS = 4,
  Request_Type_PING = 5
};
bool Request_Type_IsValid(int value);
const Request_Type Request_Type_Type_MIN = Request_Type_NONE;
const Request_Type Request_Type_Type_MAX = Request_Type_PING;
const int Request_Type_Type_ARRAYSIZE = Request_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_Type_descriptor();
inline const ::std::string& Request_Type_Name(Request_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_Type_descriptor(), value);
}
inline bool Request_Type_Parse(
    const ::std::string& name, Request_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_Type>(
    Request_Type_descriptor(), name, value);
}
enum Reply_ErrType {
  Reply_ErrType_NONE = 0,
  Reply_ErrType_VERSION = 1,
  Reply_ErrType_HEIGHT = 2,
  Reply_ErrType_REQNONCE = 3,
  Reply_ErrType_STALE = 4,
  Reply_ErrType_INVALID = 5,
  Reply_ErrType_DUPLICATE = 6
};
bool Reply_ErrType_IsValid(int value);
const Reply_ErrType Reply_ErrType_ErrType_MIN = Reply_ErrType_NONE;
const Reply_ErrType Reply_ErrType_ErrType_MAX = Reply_ErrType_DUPLICATE;
const int Reply_ErrType_ErrType_ARRAYSIZE = Reply_ErrType_ErrType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reply_ErrType_descriptor();
inline const ::std::string& Reply_ErrType_Name(Reply_ErrType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reply_ErrType_descriptor(), value);
}
inline bool Reply_ErrType_Parse(
    const ::std::string& name, Reply_ErrType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reply_ErrType>(
    Reply_ErrType_descriptor(), name, value);
}
// ===================================================================

class Block : public ::google::protobuf::Message {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  Block* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 height = 1;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 1;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // required string hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // required string prevhash = 3;
  inline bool has_prevhash() const;
  inline void clear_prevhash();
  static const int kPrevhashFieldNumber = 3;
  inline const ::std::string& prevhash() const;
  inline void set_prevhash(const ::std::string& value);
  inline void set_prevhash(const char* value);
  inline void set_prevhash(const char* value, size_t size);
  inline ::std::string* mutable_prevhash();
  inline ::std::string* release_prevhash();
  inline void set_allocated_prevhash(::std::string* prevhash);

  // required uint32 reqdiff = 4;
  inline bool has_reqdiff() const;
  inline void clear_reqdiff();
  static const int kReqdiffFieldNumber = 4;
  inline ::google::protobuf::uint32 reqdiff() const;
  inline void set_reqdiff(::google::protobuf::uint32 value);

  // required uint32 minshare = 5;
  inline bool has_minshare() const;
  inline void clear_minshare();
  static const int kMinshareFieldNumber = 5;
  inline ::google::protobuf::uint32 minshare() const;
  inline void set_minshare(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.Block)
 private:
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_prevhash();
  inline void clear_has_prevhash();
  inline void set_has_reqdiff();
  inline void clear_has_reqdiff();
  inline void set_has_minshare();
  inline void clear_has_minshare();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hash_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 reqdiff_;
  ::std::string* prevhash_;
  ::google::protobuf::uint32 minshare_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static Block* default_instance_;
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  void Swap(Signal* other);

  // implements Message ----------------------------------------------

  Signal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Signal_Type Type;
  static const Type NEWBLOCK = Signal_Type_NEWBLOCK;
  static const Type SHUTDOWN = Signal_Type_SHUTDOWN;
  static inline bool Type_IsValid(int value) {
    return Signal_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Signal_Type_Type_MIN;
  static const Type Type_MAX =
    Signal_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Signal_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Signal_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Signal_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Signal_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .pool.proto.Signal.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pool::proto::Signal_Type type() const;
  inline void set_type(::pool::proto::Signal_Type value);

  // optional .pool.proto.Block block = 2;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 2;
  inline const ::pool::proto::Block& block() const;
  inline ::pool::proto::Block* mutable_block();
  inline ::pool::proto::Block* release_block();
  inline void set_allocated_block(::pool::proto::Block* block);

  // @@protoc_insertion_point(class_scope:pool.proto.Signal)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_block();
  inline void clear_has_block();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pool::proto::Block* block_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static Signal* default_instance_;
};
// -------------------------------------------------------------------

class ClientStats : public ::google::protobuf::Message {
 public:
  ClientStats();
  virtual ~ClientStats();

  ClientStats(const ClientStats& from);

  inline ClientStats& operator=(const ClientStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientStats& default_instance();

  void Swap(ClientStats* other);

  // implements Message ----------------------------------------------

  ClientStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientStats& from);
  void MergeFrom(const ClientStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string addr = 1;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const char* value, size_t size);
  inline ::std::string* mutable_addr();
  inline ::std::string* release_addr();
  inline void set_allocated_addr(::std::string* addr);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required fixed64 clientid = 3;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 3;
  inline ::google::protobuf::uint64 clientid() const;
  inline void set_clientid(::google::protobuf::uint64 value);

  // required fixed64 instanceid = 4;
  inline bool has_instanceid() const;
  inline void clear_instanceid();
  static const int kInstanceidFieldNumber = 4;
  inline ::google::protobuf::uint64 instanceid() const;
  inline void set_instanceid(::google::protobuf::uint64 value);

  // required uint32 version = 10;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 10;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required float cpd = 11;
  inline bool has_cpd() const;
  inline void clear_cpd();
  static const int kCpdFieldNumber = 11;
  inline float cpd() const;
  inline void set_cpd(float value);

  // required uint32 latency = 12;
  inline bool has_latency() const;
  inline void clear_latency();
  static const int kLatencyFieldNumber = 12;
  inline ::google::protobuf::uint32 latency() const;
  inline void set_latency(::google::protobuf::uint32 value);

  // required uint32 temp = 13;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 13;
  inline ::google::protobuf::uint32 temp() const;
  inline void set_temp(::google::protobuf::uint32 value);

  // required uint32 errors = 14;
  inline bool has_errors() const;
  inline void clear_errors();
  static const int kErrorsFieldNumber = 14;
  inline ::google::protobuf::uint32 errors() const;
  inline void set_errors(::google::protobuf::uint32 value);

  // required uint32 ngpus = 15;
  inline bool has_ngpus() const;
  inline void clear_ngpus();
  static const int kNgpusFieldNumber = 15;
  inline ::google::protobuf::uint32 ngpus() const;
  inline void set_ngpus(::google::protobuf::uint32 value);

  // required uint32 height = 16;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 16;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.ClientStats)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_cpd();
  inline void clear_has_cpd();
  inline void set_has_latency();
  inline void clear_has_latency();
  inline void set_has_temp();
  inline void clear_has_temp();
  inline void set_has_errors();
  inline void clear_has_errors();
  inline void set_has_ngpus();
  inline void clear_has_ngpus();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* addr_;
  ::std::string* name_;
  ::google::protobuf::uint64 clientid_;
  ::google::protobuf::uint64 instanceid_;
  ::google::protobuf::uint32 version_;
  float cpd_;
  ::google::protobuf::uint32 latency_;
  ::google::protobuf::uint32 temp_;
  ::google::protobuf::uint32 errors_;
  ::google::protobuf::uint32 ngpus_;
  ::google::protobuf::uint32 height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static ClientStats* default_instance_;
};
// -------------------------------------------------------------------

class Share : public ::google::protobuf::Message {
 public:
  Share();
  virtual ~Share();

  Share(const Share& from);

  inline Share& operator=(const Share& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Share& default_instance();

  void Swap(Share* other);

  // implements Message ----------------------------------------------

  Share* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Share& from);
  void MergeFrom(const Share& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string addr = 1;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const char* value, size_t size);
  inline ::std::string* mutable_addr();
  inline ::std::string* release_addr();
  inline void set_allocated_addr(::std::string* addr);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required fixed64 clientid = 3;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 3;
  inline ::google::protobuf::uint64 clientid() const;
  inline void set_clientid(::google::protobuf::uint64 value);

  // optional uint32 gpuid = 4;
  inline bool has_gpuid() const;
  inline void clear_gpuid();
  static const int kGpuidFieldNumber = 4;
  inline ::google::protobuf::uint32 gpuid() const;
  inline void set_gpuid(::google::protobuf::uint32 value);

  // required string hash = 10;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 10;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // required string merkle = 11;
  inline bool has_merkle() const;
  inline void clear_merkle();
  static const int kMerkleFieldNumber = 11;
  inline const ::std::string& merkle() const;
  inline void set_merkle(const ::std::string& value);
  inline void set_merkle(const char* value);
  inline void set_merkle(const char* value, size_t size);
  inline ::std::string* mutable_merkle();
  inline ::std::string* release_merkle();
  inline void set_allocated_merkle(::std::string* merkle);

  // required uint32 time = 12;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 12;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required uint32 bits = 13;
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 13;
  inline ::google::protobuf::uint32 bits() const;
  inline void set_bits(::google::protobuf::uint32 value);

  // required uint32 nonce = 14;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 14;
  inline ::google::protobuf::uint32 nonce() const;
  inline void set_nonce(::google::protobuf::uint32 value);

  // required string multi = 15;
  inline bool has_multi() const;
  inline void clear_multi();
  static const int kMultiFieldNumber = 15;
  inline const ::std::string& multi() const;
  inline void set_multi(const ::std::string& value);
  inline void set_multi(const char* value);
  inline void set_multi(const char* value, size_t size);
  inline ::std::string* mutable_multi();
  inline ::std::string* release_multi();
  inline void set_allocated_multi(::std::string* multi);

  // optional string blockhash = 16;
  inline bool has_blockhash() const;
  inline void clear_blockhash();
  static const int kBlockhashFieldNumber = 16;
  inline const ::std::string& blockhash() const;
  inline void set_blockhash(const ::std::string& value);
  inline void set_blockhash(const char* value);
  inline void set_blockhash(const char* value, size_t size);
  inline ::std::string* mutable_blockhash();
  inline ::std::string* release_blockhash();
  inline void set_allocated_blockhash(::std::string* blockhash);

  // required uint32 height = 20;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 20;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // required uint32 length = 21;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 21;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);

  // required uint32 chaintype = 22;
  inline bool has_chaintype() const;
  inline void clear_chaintype();
  static const int kChaintypeFieldNumber = 22;
  inline ::google::protobuf::uint32 chaintype() const;
  inline void set_chaintype(::google::protobuf::uint32 value);

  // required bool isblock = 23;
  inline bool has_isblock() const;
  inline void clear_isblock();
  static const int kIsblockFieldNumber = 23;
  inline bool isblock() const;
  inline void set_isblock(bool value);

  // optional uint64 genvalue = 24;
  inline bool has_genvalue() const;
  inline void clear_genvalue();
  static const int kGenvalueFieldNumber = 24;
  inline ::google::protobuf::uint64 genvalue() const;
  inline void set_genvalue(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pool.proto.Share)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_gpuid();
  inline void clear_has_gpuid();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_merkle();
  inline void clear_has_merkle();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_bits();
  inline void clear_has_bits();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_multi();
  inline void clear_has_multi();
  inline void set_has_blockhash();
  inline void clear_has_blockhash();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_chaintype();
  inline void clear_has_chaintype();
  inline void set_has_isblock();
  inline void clear_has_isblock();
  inline void set_has_genvalue();
  inline void clear_has_genvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* addr_;
  ::std::string* name_;
  ::google::protobuf::uint64 clientid_;
  ::std::string* hash_;
  ::google::protobuf::uint32 gpuid_;
  ::google::protobuf::uint32 time_;
  ::std::string* merkle_;
  ::google::protobuf::uint32 bits_;
  ::google::protobuf::uint32 nonce_;
  ::std::string* multi_;
  ::std::string* blockhash_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 length_;
  ::google::protobuf::uint32 chaintype_;
  bool isblock_;
  ::google::protobuf::uint64 genvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static Share* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_Type Type;
  static const Type NONE = Request_Type_NONE;
  static const Type CONNECT = Request_Type_CONNECT;
  static const Type GETWORK = Request_Type_GETWORK;
  static const Type SHARE = Request_Type_SHARE;
  static const Type STATS = Request_Type_STATS;
  static const Type PING = Request_Type_PING;
  static inline bool Type_IsValid(int value) {
    return Request_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Request_Type_Type_MIN;
  static const Type Type_MAX =
    Request_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Request_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Request_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Request_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Request_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .pool.proto.Request.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pool::proto::Request_Type type() const;
  inline void set_type(::pool::proto::Request_Type value);

  // required uint32 reqid = 2;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqidFieldNumber = 2;
  inline ::google::protobuf::uint32 reqid() const;
  inline void set_reqid(::google::protobuf::uint32 value);

  // optional uint32 version = 10;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 10;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional uint32 height = 11;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 11;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // optional bytes reqnonce = 12;
  inline bool has_reqnonce() const;
  inline void clear_reqnonce();
  static const int kReqnonceFieldNumber = 12;
  inline const ::std::string& reqnonce() const;
  inline void set_reqnonce(const ::std::string& value);
  inline void set_reqnonce(const char* value);
  inline void set_reqnonce(const void* value, size_t size);
  inline ::std::string* mutable_reqnonce();
  inline ::std::string* release_reqnonce();
  inline void set_allocated_reqnonce(::std::string* reqnonce);

  // optional .pool.proto.Share share = 20;
  inline bool has_share() const;
  inline void clear_share();
  static const int kShareFieldNumber = 20;
  inline const ::pool::proto::Share& share() const;
  inline ::pool::proto::Share* mutable_share();
  inline ::pool::proto::Share* release_share();
  inline void set_allocated_share(::pool::proto::Share* share);

  // optional .pool.proto.ClientStats stats = 21;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 21;
  inline const ::pool::proto::ClientStats& stats() const;
  inline ::pool::proto::ClientStats* mutable_stats();
  inline ::pool::proto::ClientStats* release_stats();
  inline void set_allocated_stats(::pool::proto::ClientStats* stats);

  // @@protoc_insertion_point(class_scope:pool.proto.Request)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_reqnonce();
  inline void clear_has_reqnonce();
  inline void set_has_share();
  inline void clear_has_share();
  inline void set_has_stats();
  inline void clear_has_stats();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 reqid_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 height_;
  ::std::string* reqnonce_;
  ::pool::proto::Share* share_;
  ::pool::proto::ClientStats* stats_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class ServerInfo : public ::google::protobuf::Message {
 public:
  ServerInfo();
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfo& default_instance();

  void Swap(ServerInfo* other);

  // implements Message ----------------------------------------------

  ServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string host = 1;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 1;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // required uint32 router = 2;
  inline bool has_router() const;
  inline void clear_router();
  static const int kRouterFieldNumber = 2;
  inline ::google::protobuf::uint32 router() const;
  inline void set_router(::google::protobuf::uint32 value);

  // required uint32 pub = 3;
  inline bool has_pub() const;
  inline void clear_pub();
  static const int kPubFieldNumber = 3;
  inline ::google::protobuf::uint32 pub() const;
  inline void set_pub(::google::protobuf::uint32 value);

  // required uint32 target = 4;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 4;
  inline ::google::protobuf::uint32 target() const;
  inline void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.ServerInfo)
 private:
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_router();
  inline void clear_has_router();
  inline void set_has_pub();
  inline void clear_has_pub();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* host_;
  ::google::protobuf::uint32 router_;
  ::google::protobuf::uint32 pub_;
  ::google::protobuf::uint32 target_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static ServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class Work : public ::google::protobuf::Message {
 public:
  Work();
  virtual ~Work();

  Work(const Work& from);

  inline Work& operator=(const Work& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Work& default_instance();

  void Swap(Work* other);

  // implements Message ----------------------------------------------

  Work* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Work& from);
  void MergeFrom(const Work& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 height = 1;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 1;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // required string merkle = 2;
  inline bool has_merkle() const;
  inline void clear_merkle();
  static const int kMerkleFieldNumber = 2;
  inline const ::std::string& merkle() const;
  inline void set_merkle(const ::std::string& value);
  inline void set_merkle(const char* value);
  inline void set_merkle(const char* value, size_t size);
  inline ::std::string* mutable_merkle();
  inline ::std::string* release_merkle();
  inline void set_allocated_merkle(::std::string* merkle);

  // required uint32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required uint32 bits = 4;
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 4;
  inline ::google::protobuf::uint32 bits() const;
  inline void set_bits(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.Work)
 private:
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_merkle();
  inline void clear_has_merkle();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_bits();
  inline void clear_has_bits();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* merkle_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 bits_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static Work* default_instance_;
};
// -------------------------------------------------------------------

class Reply : public ::google::protobuf::Message {
 public:
  Reply();
  virtual ~Reply();

  Reply(const Reply& from);

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply& default_instance();

  void Swap(Reply* other);

  // implements Message ----------------------------------------------

  Reply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply& from);
  void MergeFrom(const Reply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Reply_ErrType ErrType;
  static const ErrType NONE = Reply_ErrType_NONE;
  static const ErrType VERSION = Reply_ErrType_VERSION;
  static const ErrType HEIGHT = Reply_ErrType_HEIGHT;
  static const ErrType REQNONCE = Reply_ErrType_REQNONCE;
  static const ErrType STALE = Reply_ErrType_STALE;
  static const ErrType INVALID = Reply_ErrType_INVALID;
  static const ErrType DUPLICATE = Reply_ErrType_DUPLICATE;
  static inline bool ErrType_IsValid(int value) {
    return Reply_ErrType_IsValid(value);
  }
  static const ErrType ErrType_MIN =
    Reply_ErrType_ErrType_MIN;
  static const ErrType ErrType_MAX =
    Reply_ErrType_ErrType_MAX;
  static const int ErrType_ARRAYSIZE =
    Reply_ErrType_ErrType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrType_descriptor() {
    return Reply_ErrType_descriptor();
  }
  static inline const ::std::string& ErrType_Name(ErrType value) {
    return Reply_ErrType_Name(value);
  }
  static inline bool ErrType_Parse(const ::std::string& name,
      ErrType* value) {
    return Reply_ErrType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .pool.proto.Request.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pool::proto::Request_Type type() const;
  inline void set_type(::pool::proto::Request_Type value);

  // required uint32 reqid = 2;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqidFieldNumber = 2;
  inline ::google::protobuf::uint32 reqid() const;
  inline void set_reqid(::google::protobuf::uint32 value);

  // required .pool.proto.Reply.ErrType error = 10;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 10;
  inline ::pool::proto::Reply_ErrType error() const;
  inline void set_error(::pool::proto::Reply_ErrType value);

  // optional string errstr = 11;
  inline bool has_errstr() const;
  inline void clear_errstr();
  static const int kErrstrFieldNumber = 11;
  inline const ::std::string& errstr() const;
  inline void set_errstr(const ::std::string& value);
  inline void set_errstr(const char* value);
  inline void set_errstr(const char* value, size_t size);
  inline ::std::string* mutable_errstr();
  inline ::std::string* release_errstr();
  inline void set_allocated_errstr(::std::string* errstr);

  // optional .pool.proto.ServerInfo sinfo = 20;
  inline bool has_sinfo() const;
  inline void clear_sinfo();
  static const int kSinfoFieldNumber = 20;
  inline const ::pool::proto::ServerInfo& sinfo() const;
  inline ::pool::proto::ServerInfo* mutable_sinfo();
  inline ::pool::proto::ServerInfo* release_sinfo();
  inline void set_allocated_sinfo(::pool::proto::ServerInfo* sinfo);

  // optional .pool.proto.Work work = 21;
  inline bool has_work() const;
  inline void clear_work();
  static const int kWorkFieldNumber = 21;
  inline const ::pool::proto::Work& work() const;
  inline ::pool::proto::Work* mutable_work();
  inline ::pool::proto::Work* release_work();
  inline void set_allocated_work(::pool::proto::Work* work);

  // optional .pool.proto.Block block = 22;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 22;
  inline const ::pool::proto::Block& block() const;
  inline ::pool::proto::Block* mutable_block();
  inline ::pool::proto::Block* release_block();
  inline void set_allocated_block(::pool::proto::Block* block);

  // @@protoc_insertion_point(class_scope:pool.proto.Reply)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_errstr();
  inline void clear_has_errstr();
  inline void set_has_sinfo();
  inline void clear_has_sinfo();
  inline void set_has_work();
  inline void clear_has_work();
  inline void set_has_block();
  inline void clear_has_block();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 reqid_;
  ::std::string* errstr_;
  ::pool::proto::ServerInfo* sinfo_;
  ::pool::proto::Work* work_;
  ::pool::proto::Block* block_;
  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static Reply* default_instance_;
};
// -------------------------------------------------------------------

class ReqStats : public ::google::protobuf::Message {
 public:
  ReqStats();
  virtual ~ReqStats();

  ReqStats(const ReqStats& from);

  inline ReqStats& operator=(const ReqStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqStats& default_instance();

  void Swap(ReqStats* other);

  // implements Message ----------------------------------------------

  ReqStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqStats& from);
  void MergeFrom(const ReqStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pool.proto.Request.Type reqtype = 1;
  inline bool has_reqtype() const;
  inline void clear_reqtype();
  static const int kReqtypeFieldNumber = 1;
  inline ::pool::proto::Request_Type reqtype() const;
  inline void set_reqtype(::pool::proto::Request_Type value);

  // required .pool.proto.Reply.ErrType errtype = 2;
  inline bool has_errtype() const;
  inline void clear_errtype();
  static const int kErrtypeFieldNumber = 2;
  inline ::pool::proto::Reply_ErrType errtype() const;
  inline void set_errtype(::pool::proto::Reply_ErrType value);

  // required uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.ReqStats)
 private:
  inline void set_has_reqtype();
  inline void clear_has_reqtype();
  inline void set_has_errtype();
  inline void clear_has_errtype();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int reqtype_;
  int errtype_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static ReqStats* default_instance_;
};
// -------------------------------------------------------------------

class ServerStats : public ::google::protobuf::Message {
 public:
  ServerStats();
  virtual ~ServerStats();

  ServerStats(const ServerStats& from);

  inline ServerStats& operator=(const ServerStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerStats& default_instance();

  void Swap(ServerStats* other);

  // implements Message ----------------------------------------------

  ServerStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerStats& from);
  void MergeFrom(const ServerStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 thread = 2;
  inline bool has_thread() const;
  inline void clear_thread();
  static const int kThreadFieldNumber = 2;
  inline ::google::protobuf::uint32 thread() const;
  inline void set_thread(::google::protobuf::uint32 value);

  // required uint32 workers = 10;
  inline bool has_workers() const;
  inline void clear_workers();
  static const int kWorkersFieldNumber = 10;
  inline ::google::protobuf::uint32 workers() const;
  inline void set_workers(::google::protobuf::uint32 value);

  // required uint32 latency = 11;
  inline bool has_latency() const;
  inline void clear_latency();
  static const int kLatencyFieldNumber = 11;
  inline ::google::protobuf::uint32 latency() const;
  inline void set_latency(::google::protobuf::uint32 value);

  // required float cpd = 12;
  inline bool has_cpd() const;
  inline void clear_cpd();
  static const int kCpdFieldNumber = 12;
  inline float cpd() const;
  inline void set_cpd(float value);

  // repeated .pool.proto.ReqStats reqstats = 20;
  inline int reqstats_size() const;
  inline void clear_reqstats();
  static const int kReqstatsFieldNumber = 20;
  inline const ::pool::proto::ReqStats& reqstats(int index) const;
  inline ::pool::proto::ReqStats* mutable_reqstats(int index);
  inline ::pool::proto::ReqStats* add_reqstats();
  inline const ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >&
      reqstats() const;
  inline ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >*
      mutable_reqstats();

  // @@protoc_insertion_point(class_scope:pool.proto.ServerStats)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_thread();
  inline void clear_has_thread();
  inline void set_has_workers();
  inline void clear_has_workers();
  inline void set_has_latency();
  inline void clear_has_latency();
  inline void set_has_cpd();
  inline void clear_has_cpd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 thread_;
  ::google::protobuf::uint32 workers_;
  ::google::protobuf::uint32 latency_;
  float cpd_;
  ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats > reqstats_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static ServerStats* default_instance_;
};
// -------------------------------------------------------------------

class Data : public ::google::protobuf::Message {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Data& default_instance();

  void Swap(Data* other);

  // implements Message ----------------------------------------------

  Data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pool.proto.Share share = 1;
  inline bool has_share() const;
  inline void clear_share();
  static const int kShareFieldNumber = 1;
  inline const ::pool::proto::Share& share() const;
  inline ::pool::proto::Share* mutable_share();
  inline ::pool::proto::Share* release_share();
  inline void set_allocated_share(::pool::proto::Share* share);

  // optional .pool.proto.ClientStats clientstats = 2;
  inline bool has_clientstats() const;
  inline void clear_clientstats();
  static const int kClientstatsFieldNumber = 2;
  inline const ::pool::proto::ClientStats& clientstats() const;
  inline ::pool::proto::ClientStats* mutable_clientstats();
  inline ::pool::proto::ClientStats* release_clientstats();
  inline void set_allocated_clientstats(::pool::proto::ClientStats* clientstats);

  // optional .pool.proto.ServerStats serverstats = 3;
  inline bool has_serverstats() const;
  inline void clear_serverstats();
  static const int kServerstatsFieldNumber = 3;
  inline const ::pool::proto::ServerStats& serverstats() const;
  inline ::pool::proto::ServerStats* mutable_serverstats();
  inline ::pool::proto::ServerStats* release_serverstats();
  inline void set_allocated_serverstats(::pool::proto::ServerStats* serverstats);

  // @@protoc_insertion_point(class_scope:pool.proto.Data)
 private:
  inline void set_has_share();
  inline void clear_has_share();
  inline void set_has_clientstats();
  inline void clear_has_clientstats();
  inline void set_has_serverstats();
  inline void clear_has_serverstats();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pool::proto::Share* share_;
  ::pool::proto::ClientStats* clientstats_;
  ::pool::proto::ServerStats* serverstats_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static Data* default_instance_;
};
// ===================================================================


// ===================================================================

// Block

// required uint32 height = 1;
inline bool Block::has_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Block::set_has_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Block::clear_has_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Block::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Block::height() const {
  return height_;
}
inline void Block::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// required string hash = 2;
inline bool Block::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Block::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Block::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Block::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& Block::hash() const {
  return *hash_;
}
inline void Block::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void Block::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void Block::set_hash(const char* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Block::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* Block::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Block::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string prevhash = 3;
inline bool Block::has_prevhash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Block::set_has_prevhash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Block::clear_has_prevhash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Block::clear_prevhash() {
  if (prevhash_ != &::google::protobuf::internal::kEmptyString) {
    prevhash_->clear();
  }
  clear_has_prevhash();
}
inline const ::std::string& Block::prevhash() const {
  return *prevhash_;
}
inline void Block::set_prevhash(const ::std::string& value) {
  set_has_prevhash();
  if (prevhash_ == &::google::protobuf::internal::kEmptyString) {
    prevhash_ = new ::std::string;
  }
  prevhash_->assign(value);
}
inline void Block::set_prevhash(const char* value) {
  set_has_prevhash();
  if (prevhash_ == &::google::protobuf::internal::kEmptyString) {
    prevhash_ = new ::std::string;
  }
  prevhash_->assign(value);
}
inline void Block::set_prevhash(const char* value, size_t size) {
  set_has_prevhash();
  if (prevhash_ == &::google::protobuf::internal::kEmptyString) {
    prevhash_ = new ::std::string;
  }
  prevhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Block::mutable_prevhash() {
  set_has_prevhash();
  if (prevhash_ == &::google::protobuf::internal::kEmptyString) {
    prevhash_ = new ::std::string;
  }
  return prevhash_;
}
inline ::std::string* Block::release_prevhash() {
  clear_has_prevhash();
  if (prevhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prevhash_;
    prevhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Block::set_allocated_prevhash(::std::string* prevhash) {
  if (prevhash_ != &::google::protobuf::internal::kEmptyString) {
    delete prevhash_;
  }
  if (prevhash) {
    set_has_prevhash();
    prevhash_ = prevhash;
  } else {
    clear_has_prevhash();
    prevhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 reqdiff = 4;
inline bool Block::has_reqdiff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Block::set_has_reqdiff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Block::clear_has_reqdiff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Block::clear_reqdiff() {
  reqdiff_ = 0u;
  clear_has_reqdiff();
}
inline ::google::protobuf::uint32 Block::reqdiff() const {
  return reqdiff_;
}
inline void Block::set_reqdiff(::google::protobuf::uint32 value) {
  set_has_reqdiff();
  reqdiff_ = value;
}

// required uint32 minshare = 5;
inline bool Block::has_minshare() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Block::set_has_minshare() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Block::clear_has_minshare() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Block::clear_minshare() {
  minshare_ = 0u;
  clear_has_minshare();
}
inline ::google::protobuf::uint32 Block::minshare() const {
  return minshare_;
}
inline void Block::set_minshare(::google::protobuf::uint32 value) {
  set_has_minshare();
  minshare_ = value;
}

// -------------------------------------------------------------------

// Signal

// required .pool.proto.Signal.Type type = 1;
inline bool Signal::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signal::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signal::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pool::proto::Signal_Type Signal::type() const {
  return static_cast< ::pool::proto::Signal_Type >(type_);
}
inline void Signal::set_type(::pool::proto::Signal_Type value) {
  assert(::pool::proto::Signal_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .pool.proto.Block block = 2;
inline bool Signal::has_block() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal::set_has_block() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Signal::clear_has_block() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Signal::clear_block() {
  if (block_ != NULL) block_->::pool::proto::Block::Clear();
  clear_has_block();
}
inline const ::pool::proto::Block& Signal::block() const {
  return block_ != NULL ? *block_ : *default_instance_->block_;
}
inline ::pool::proto::Block* Signal::mutable_block() {
  set_has_block();
  if (block_ == NULL) block_ = new ::pool::proto::Block;
  return block_;
}
inline ::pool::proto::Block* Signal::release_block() {
  clear_has_block();
  ::pool::proto::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void Signal::set_allocated_block(::pool::proto::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
}

// -------------------------------------------------------------------

// ClientStats

// required string addr = 1;
inline bool ClientStats::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientStats::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientStats::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientStats::clear_addr() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    addr_->clear();
  }
  clear_has_addr();
}
inline const ::std::string& ClientStats::addr() const {
  return *addr_;
}
inline void ClientStats::set_addr(const ::std::string& value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void ClientStats::set_addr(const char* value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void ClientStats::set_addr(const char* value, size_t size) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientStats::mutable_addr() {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  return addr_;
}
inline ::std::string* ClientStats::release_addr() {
  clear_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_;
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientStats::set_allocated_addr(::std::string* addr) {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    delete addr_;
  }
  if (addr) {
    set_has_addr();
    addr_ = addr;
  } else {
    clear_has_addr();
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool ClientStats::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientStats::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientStats::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientStats::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClientStats::name() const {
  return *name_;
}
inline void ClientStats::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientStats::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientStats::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientStats::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClientStats::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientStats::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 clientid = 3;
inline bool ClientStats::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientStats::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientStats::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientStats::clear_clientid() {
  clientid_ = GOOGLE_ULONGLONG(0);
  clear_has_clientid();
}
inline ::google::protobuf::uint64 ClientStats::clientid() const {
  return clientid_;
}
inline void ClientStats::set_clientid(::google::protobuf::uint64 value) {
  set_has_clientid();
  clientid_ = value;
}

// required fixed64 instanceid = 4;
inline bool ClientStats::has_instanceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientStats::set_has_instanceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientStats::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientStats::clear_instanceid() {
  instanceid_ = GOOGLE_ULONGLONG(0);
  clear_has_instanceid();
}
inline ::google::protobuf::uint64 ClientStats::instanceid() const {
  return instanceid_;
}
inline void ClientStats::set_instanceid(::google::protobuf::uint64 value) {
  set_has_instanceid();
  instanceid_ = value;
}

// required uint32 version = 10;
inline bool ClientStats::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientStats::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientStats::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientStats::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 ClientStats::version() const {
  return version_;
}
inline void ClientStats::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// required float cpd = 11;
inline bool ClientStats::has_cpd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientStats::set_has_cpd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientStats::clear_has_cpd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientStats::clear_cpd() {
  cpd_ = 0;
  clear_has_cpd();
}
inline float ClientStats::cpd() const {
  return cpd_;
}
inline void ClientStats::set_cpd(float value) {
  set_has_cpd();
  cpd_ = value;
}

// required uint32 latency = 12;
inline bool ClientStats::has_latency() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientStats::set_has_latency() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientStats::clear_has_latency() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientStats::clear_latency() {
  latency_ = 0u;
  clear_has_latency();
}
inline ::google::protobuf::uint32 ClientStats::latency() const {
  return latency_;
}
inline void ClientStats::set_latency(::google::protobuf::uint32 value) {
  set_has_latency();
  latency_ = value;
}

// required uint32 temp = 13;
inline bool ClientStats::has_temp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientStats::set_has_temp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientStats::clear_has_temp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientStats::clear_temp() {
  temp_ = 0u;
  clear_has_temp();
}
inline ::google::protobuf::uint32 ClientStats::temp() const {
  return temp_;
}
inline void ClientStats::set_temp(::google::protobuf::uint32 value) {
  set_has_temp();
  temp_ = value;
}

// required uint32 errors = 14;
inline bool ClientStats::has_errors() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientStats::set_has_errors() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientStats::clear_has_errors() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientStats::clear_errors() {
  errors_ = 0u;
  clear_has_errors();
}
inline ::google::protobuf::uint32 ClientStats::errors() const {
  return errors_;
}
inline void ClientStats::set_errors(::google::protobuf::uint32 value) {
  set_has_errors();
  errors_ = value;
}

// required uint32 ngpus = 15;
inline bool ClientStats::has_ngpus() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientStats::set_has_ngpus() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientStats::clear_has_ngpus() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientStats::clear_ngpus() {
  ngpus_ = 0u;
  clear_has_ngpus();
}
inline ::google::protobuf::uint32 ClientStats::ngpus() const {
  return ngpus_;
}
inline void ClientStats::set_ngpus(::google::protobuf::uint32 value) {
  set_has_ngpus();
  ngpus_ = value;
}

// required uint32 height = 16;
inline bool ClientStats::has_height() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientStats::set_has_height() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientStats::clear_has_height() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientStats::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 ClientStats::height() const {
  return height_;
}
inline void ClientStats::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// Share

// required string addr = 1;
inline bool Share::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Share::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Share::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Share::clear_addr() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    addr_->clear();
  }
  clear_has_addr();
}
inline const ::std::string& Share::addr() const {
  return *addr_;
}
inline void Share::set_addr(const ::std::string& value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void Share::set_addr(const char* value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void Share::set_addr(const char* value, size_t size) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Share::mutable_addr() {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  return addr_;
}
inline ::std::string* Share::release_addr() {
  clear_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_;
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Share::set_allocated_addr(::std::string* addr) {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    delete addr_;
  }
  if (addr) {
    set_has_addr();
    addr_ = addr;
  } else {
    clear_has_addr();
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool Share::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Share::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Share::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Share::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Share::name() const {
  return *name_;
}
inline void Share::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Share::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Share::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Share::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Share::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Share::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 clientid = 3;
inline bool Share::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Share::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Share::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Share::clear_clientid() {
  clientid_ = GOOGLE_ULONGLONG(0);
  clear_has_clientid();
}
inline ::google::protobuf::uint64 Share::clientid() const {
  return clientid_;
}
inline void Share::set_clientid(::google::protobuf::uint64 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 gpuid = 4;
inline bool Share::has_gpuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Share::set_has_gpuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Share::clear_has_gpuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Share::clear_gpuid() {
  gpuid_ = 0u;
  clear_has_gpuid();
}
inline ::google::protobuf::uint32 Share::gpuid() const {
  return gpuid_;
}
inline void Share::set_gpuid(::google::protobuf::uint32 value) {
  set_has_gpuid();
  gpuid_ = value;
}

// required string hash = 10;
inline bool Share::has_hash() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Share::set_has_hash() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Share::clear_has_hash() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Share::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& Share::hash() const {
  return *hash_;
}
inline void Share::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void Share::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void Share::set_hash(const char* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Share::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* Share::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Share::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string merkle = 11;
inline bool Share::has_merkle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Share::set_has_merkle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Share::clear_has_merkle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Share::clear_merkle() {
  if (merkle_ != &::google::protobuf::internal::kEmptyString) {
    merkle_->clear();
  }
  clear_has_merkle();
}
inline const ::std::string& Share::merkle() const {
  return *merkle_;
}
inline void Share::set_merkle(const ::std::string& value) {
  set_has_merkle();
  if (merkle_ == &::google::protobuf::internal::kEmptyString) {
    merkle_ = new ::std::string;
  }
  merkle_->assign(value);
}
inline void Share::set_merkle(const char* value) {
  set_has_merkle();
  if (merkle_ == &::google::protobuf::internal::kEmptyString) {
    merkle_ = new ::std::string;
  }
  merkle_->assign(value);
}
inline void Share::set_merkle(const char* value, size_t size) {
  set_has_merkle();
  if (merkle_ == &::google::protobuf::internal::kEmptyString) {
    merkle_ = new ::std::string;
  }
  merkle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Share::mutable_merkle() {
  set_has_merkle();
  if (merkle_ == &::google::protobuf::internal::kEmptyString) {
    merkle_ = new ::std::string;
  }
  return merkle_;
}
inline ::std::string* Share::release_merkle() {
  clear_has_merkle();
  if (merkle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merkle_;
    merkle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Share::set_allocated_merkle(::std::string* merkle) {
  if (merkle_ != &::google::protobuf::internal::kEmptyString) {
    delete merkle_;
  }
  if (merkle) {
    set_has_merkle();
    merkle_ = merkle;
  } else {
    clear_has_merkle();
    merkle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 time = 12;
inline bool Share::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Share::set_has_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Share::clear_has_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Share::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 Share::time() const {
  return time_;
}
inline void Share::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required uint32 bits = 13;
inline bool Share::has_bits() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Share::set_has_bits() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Share::clear_has_bits() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Share::clear_bits() {
  bits_ = 0u;
  clear_has_bits();
}
inline ::google::protobuf::uint32 Share::bits() const {
  return bits_;
}
inline void Share::set_bits(::google::protobuf::uint32 value) {
  set_has_bits();
  bits_ = value;
}

// required uint32 nonce = 14;
inline bool Share::has_nonce() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Share::set_has_nonce() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Share::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Share::clear_nonce() {
  nonce_ = 0u;
  clear_has_nonce();
}
inline ::google::protobuf::uint32 Share::nonce() const {
  return nonce_;
}
inline void Share::set_nonce(::google::protobuf::uint32 value) {
  set_has_nonce();
  nonce_ = value;
}

// required string multi = 15;
inline bool Share::has_multi() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Share::set_has_multi() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Share::clear_has_multi() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Share::clear_multi() {
  if (multi_ != &::google::protobuf::internal::kEmptyString) {
    multi_->clear();
  }
  clear_has_multi();
}
inline const ::std::string& Share::multi() const {
  return *multi_;
}
inline void Share::set_multi(const ::std::string& value) {
  set_has_multi();
  if (multi_ == &::google::protobuf::internal::kEmptyString) {
    multi_ = new ::std::string;
  }
  multi_->assign(value);
}
inline void Share::set_multi(const char* value) {
  set_has_multi();
  if (multi_ == &::google::protobuf::internal::kEmptyString) {
    multi_ = new ::std::string;
  }
  multi_->assign(value);
}
inline void Share::set_multi(const char* value, size_t size) {
  set_has_multi();
  if (multi_ == &::google::protobuf::internal::kEmptyString) {
    multi_ = new ::std::string;
  }
  multi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Share::mutable_multi() {
  set_has_multi();
  if (multi_ == &::google::protobuf::internal::kEmptyString) {
    multi_ = new ::std::string;
  }
  return multi_;
}
inline ::std::string* Share::release_multi() {
  clear_has_multi();
  if (multi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = multi_;
    multi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Share::set_allocated_multi(::std::string* multi) {
  if (multi_ != &::google::protobuf::internal::kEmptyString) {
    delete multi_;
  }
  if (multi) {
    set_has_multi();
    multi_ = multi;
  } else {
    clear_has_multi();
    multi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string blockhash = 16;
inline bool Share::has_blockhash() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Share::set_has_blockhash() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Share::clear_has_blockhash() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Share::clear_blockhash() {
  if (blockhash_ != &::google::protobuf::internal::kEmptyString) {
    blockhash_->clear();
  }
  clear_has_blockhash();
}
inline const ::std::string& Share::blockhash() const {
  return *blockhash_;
}
inline void Share::set_blockhash(const ::std::string& value) {
  set_has_blockhash();
  if (blockhash_ == &::google::protobuf::internal::kEmptyString) {
    blockhash_ = new ::std::string;
  }
  blockhash_->assign(value);
}
inline void Share::set_blockhash(const char* value) {
  set_has_blockhash();
  if (blockhash_ == &::google::protobuf::internal::kEmptyString) {
    blockhash_ = new ::std::string;
  }
  blockhash_->assign(value);
}
inline void Share::set_blockhash(const char* value, size_t size) {
  set_has_blockhash();
  if (blockhash_ == &::google::protobuf::internal::kEmptyString) {
    blockhash_ = new ::std::string;
  }
  blockhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Share::mutable_blockhash() {
  set_has_blockhash();
  if (blockhash_ == &::google::protobuf::internal::kEmptyString) {
    blockhash_ = new ::std::string;
  }
  return blockhash_;
}
inline ::std::string* Share::release_blockhash() {
  clear_has_blockhash();
  if (blockhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = blockhash_;
    blockhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Share::set_allocated_blockhash(::std::string* blockhash) {
  if (blockhash_ != &::google::protobuf::internal::kEmptyString) {
    delete blockhash_;
  }
  if (blockhash) {
    set_has_blockhash();
    blockhash_ = blockhash;
  } else {
    clear_has_blockhash();
    blockhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 height = 20;
inline bool Share::has_height() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Share::set_has_height() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Share::clear_has_height() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Share::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Share::height() const {
  return height_;
}
inline void Share::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// required uint32 length = 21;
inline bool Share::has_length() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Share::set_has_length() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Share::clear_has_length() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Share::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 Share::length() const {
  return length_;
}
inline void Share::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
}

// required uint32 chaintype = 22;
inline bool Share::has_chaintype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Share::set_has_chaintype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Share::clear_has_chaintype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Share::clear_chaintype() {
  chaintype_ = 0u;
  clear_has_chaintype();
}
inline ::google::protobuf::uint32 Share::chaintype() const {
  return chaintype_;
}
inline void Share::set_chaintype(::google::protobuf::uint32 value) {
  set_has_chaintype();
  chaintype_ = value;
}

// required bool isblock = 23;
inline bool Share::has_isblock() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Share::set_has_isblock() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Share::clear_has_isblock() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Share::clear_isblock() {
  isblock_ = false;
  clear_has_isblock();
}
inline bool Share::isblock() const {
  return isblock_;
}
inline void Share::set_isblock(bool value) {
  set_has_isblock();
  isblock_ = value;
}

// optional uint64 genvalue = 24;
inline bool Share::has_genvalue() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Share::set_has_genvalue() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Share::clear_has_genvalue() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Share::clear_genvalue() {
  genvalue_ = GOOGLE_ULONGLONG(0);
  clear_has_genvalue();
}
inline ::google::protobuf::uint64 Share::genvalue() const {
  return genvalue_;
}
inline void Share::set_genvalue(::google::protobuf::uint64 value) {
  set_has_genvalue();
  genvalue_ = value;
}

// -------------------------------------------------------------------

// Request

// required .pool.proto.Request.Type type = 1;
inline bool Request::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pool::proto::Request_Type Request::type() const {
  return static_cast< ::pool::proto::Request_Type >(type_);
}
inline void Request::set_type(::pool::proto::Request_Type value) {
  assert(::pool::proto::Request_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required uint32 reqid = 2;
inline bool Request::has_reqid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_reqid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_reqid() {
  reqid_ = 0u;
  clear_has_reqid();
}
inline ::google::protobuf::uint32 Request::reqid() const {
  return reqid_;
}
inline void Request::set_reqid(::google::protobuf::uint32 value) {
  set_has_reqid();
  reqid_ = value;
}

// optional uint32 version = 10;
inline bool Request::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Request::version() const {
  return version_;
}
inline void Request::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// optional uint32 height = 11;
inline bool Request::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Request::height() const {
  return height_;
}
inline void Request::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// optional bytes reqnonce = 12;
inline bool Request::has_reqnonce() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_reqnonce() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_reqnonce() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_reqnonce() {
  if (reqnonce_ != &::google::protobuf::internal::kEmptyString) {
    reqnonce_->clear();
  }
  clear_has_reqnonce();
}
inline const ::std::string& Request::reqnonce() const {
  return *reqnonce_;
}
inline void Request::set_reqnonce(const ::std::string& value) {
  set_has_reqnonce();
  if (reqnonce_ == &::google::protobuf::internal::kEmptyString) {
    reqnonce_ = new ::std::string;
  }
  reqnonce_->assign(value);
}
inline void Request::set_reqnonce(const char* value) {
  set_has_reqnonce();
  if (reqnonce_ == &::google::protobuf::internal::kEmptyString) {
    reqnonce_ = new ::std::string;
  }
  reqnonce_->assign(value);
}
inline void Request::set_reqnonce(const void* value, size_t size) {
  set_has_reqnonce();
  if (reqnonce_ == &::google::protobuf::internal::kEmptyString) {
    reqnonce_ = new ::std::string;
  }
  reqnonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_reqnonce() {
  set_has_reqnonce();
  if (reqnonce_ == &::google::protobuf::internal::kEmptyString) {
    reqnonce_ = new ::std::string;
  }
  return reqnonce_;
}
inline ::std::string* Request::release_reqnonce() {
  clear_has_reqnonce();
  if (reqnonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqnonce_;
    reqnonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request::set_allocated_reqnonce(::std::string* reqnonce) {
  if (reqnonce_ != &::google::protobuf::internal::kEmptyString) {
    delete reqnonce_;
  }
  if (reqnonce) {
    set_has_reqnonce();
    reqnonce_ = reqnonce;
  } else {
    clear_has_reqnonce();
    reqnonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pool.proto.Share share = 20;
inline bool Request::has_share() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_share() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_share() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_share() {
  if (share_ != NULL) share_->::pool::proto::Share::Clear();
  clear_has_share();
}
inline const ::pool::proto::Share& Request::share() const {
  return share_ != NULL ? *share_ : *default_instance_->share_;
}
inline ::pool::proto::Share* Request::mutable_share() {
  set_has_share();
  if (share_ == NULL) share_ = new ::pool::proto::Share;
  return share_;
}
inline ::pool::proto::Share* Request::release_share() {
  clear_has_share();
  ::pool::proto::Share* temp = share_;
  share_ = NULL;
  return temp;
}
inline void Request::set_allocated_share(::pool::proto::Share* share) {
  delete share_;
  share_ = share;
  if (share) {
    set_has_share();
  } else {
    clear_has_share();
  }
}

// optional .pool.proto.ClientStats stats = 21;
inline bool Request::has_stats() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_stats() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_stats() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_stats() {
  if (stats_ != NULL) stats_->::pool::proto::ClientStats::Clear();
  clear_has_stats();
}
inline const ::pool::proto::ClientStats& Request::stats() const {
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::pool::proto::ClientStats* Request::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::pool::proto::ClientStats;
  return stats_;
}
inline ::pool::proto::ClientStats* Request::release_stats() {
  clear_has_stats();
  ::pool::proto::ClientStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void Request::set_allocated_stats(::pool::proto::ClientStats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
}

// -------------------------------------------------------------------

// ServerInfo

// required string host = 1;
inline bool ServerInfo::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfo::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfo::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfo::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& ServerInfo::host() const {
  return *host_;
}
inline void ServerInfo::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ServerInfo::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ServerInfo::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfo::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* ServerInfo::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfo::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 router = 2;
inline bool ServerInfo::has_router() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfo::set_has_router() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfo::clear_has_router() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfo::clear_router() {
  router_ = 0u;
  clear_has_router();
}
inline ::google::protobuf::uint32 ServerInfo::router() const {
  return router_;
}
inline void ServerInfo::set_router(::google::protobuf::uint32 value) {
  set_has_router();
  router_ = value;
}

// required uint32 pub = 3;
inline bool ServerInfo::has_pub() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerInfo::set_has_pub() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerInfo::clear_has_pub() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerInfo::clear_pub() {
  pub_ = 0u;
  clear_has_pub();
}
inline ::google::protobuf::uint32 ServerInfo::pub() const {
  return pub_;
}
inline void ServerInfo::set_pub(::google::protobuf::uint32 value) {
  set_has_pub();
  pub_ = value;
}

// required uint32 target = 4;
inline bool ServerInfo::has_target() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerInfo::set_has_target() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerInfo::clear_has_target() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerInfo::clear_target() {
  target_ = 0u;
  clear_has_target();
}
inline ::google::protobuf::uint32 ServerInfo::target() const {
  return target_;
}
inline void ServerInfo::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
}

// -------------------------------------------------------------------

// Work

// required uint32 height = 1;
inline bool Work::has_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Work::set_has_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Work::clear_has_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Work::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Work::height() const {
  return height_;
}
inline void Work::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// required string merkle = 2;
inline bool Work::has_merkle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Work::set_has_merkle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Work::clear_has_merkle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Work::clear_merkle() {
  if (merkle_ != &::google::protobuf::internal::kEmptyString) {
    merkle_->clear();
  }
  clear_has_merkle();
}
inline const ::std::string& Work::merkle() const {
  return *merkle_;
}
inline void Work::set_merkle(const ::std::string& value) {
  set_has_merkle();
  if (merkle_ == &::google::protobuf::internal::kEmptyString) {
    merkle_ = new ::std::string;
  }
  merkle_->assign(value);
}
inline void Work::set_merkle(const char* value) {
  set_has_merkle();
  if (merkle_ == &::google::protobuf::internal::kEmptyString) {
    merkle_ = new ::std::string;
  }
  merkle_->assign(value);
}
inline void Work::set_merkle(const char* value, size_t size) {
  set_has_merkle();
  if (merkle_ == &::google::protobuf::internal::kEmptyString) {
    merkle_ = new ::std::string;
  }
  merkle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Work::mutable_merkle() {
  set_has_merkle();
  if (merkle_ == &::google::protobuf::internal::kEmptyString) {
    merkle_ = new ::std::string;
  }
  return merkle_;
}
inline ::std::string* Work::release_merkle() {
  clear_has_merkle();
  if (merkle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merkle_;
    merkle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Work::set_allocated_merkle(::std::string* merkle) {
  if (merkle_ != &::google::protobuf::internal::kEmptyString) {
    delete merkle_;
  }
  if (merkle) {
    set_has_merkle();
    merkle_ = merkle;
  } else {
    clear_has_merkle();
    merkle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 time = 3;
inline bool Work::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Work::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Work::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Work::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 Work::time() const {
  return time_;
}
inline void Work::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required uint32 bits = 4;
inline bool Work::has_bits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Work::set_has_bits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Work::clear_has_bits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Work::clear_bits() {
  bits_ = 0u;
  clear_has_bits();
}
inline ::google::protobuf::uint32 Work::bits() const {
  return bits_;
}
inline void Work::set_bits(::google::protobuf::uint32 value) {
  set_has_bits();
  bits_ = value;
}

// -------------------------------------------------------------------

// Reply

// required .pool.proto.Request.Type type = 1;
inline bool Reply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reply::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pool::proto::Request_Type Reply::type() const {
  return static_cast< ::pool::proto::Request_Type >(type_);
}
inline void Reply::set_type(::pool::proto::Request_Type value) {
  assert(::pool::proto::Request_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required uint32 reqid = 2;
inline bool Reply::has_reqid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reply::set_has_reqid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reply::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reply::clear_reqid() {
  reqid_ = 0u;
  clear_has_reqid();
}
inline ::google::protobuf::uint32 Reply::reqid() const {
  return reqid_;
}
inline void Reply::set_reqid(::google::protobuf::uint32 value) {
  set_has_reqid();
  reqid_ = value;
}

// required .pool.proto.Reply.ErrType error = 10;
inline bool Reply::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reply::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reply::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reply::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::pool::proto::Reply_ErrType Reply::error() const {
  return static_cast< ::pool::proto::Reply_ErrType >(error_);
}
inline void Reply::set_error(::pool::proto::Reply_ErrType value) {
  assert(::pool::proto::Reply_ErrType_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional string errstr = 11;
inline bool Reply::has_errstr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reply::set_has_errstr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reply::clear_has_errstr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reply::clear_errstr() {
  if (errstr_ != &::google::protobuf::internal::kEmptyString) {
    errstr_->clear();
  }
  clear_has_errstr();
}
inline const ::std::string& Reply::errstr() const {
  return *errstr_;
}
inline void Reply::set_errstr(const ::std::string& value) {
  set_has_errstr();
  if (errstr_ == &::google::protobuf::internal::kEmptyString) {
    errstr_ = new ::std::string;
  }
  errstr_->assign(value);
}
inline void Reply::set_errstr(const char* value) {
  set_has_errstr();
  if (errstr_ == &::google::protobuf::internal::kEmptyString) {
    errstr_ = new ::std::string;
  }
  errstr_->assign(value);
}
inline void Reply::set_errstr(const char* value, size_t size) {
  set_has_errstr();
  if (errstr_ == &::google::protobuf::internal::kEmptyString) {
    errstr_ = new ::std::string;
  }
  errstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Reply::mutable_errstr() {
  set_has_errstr();
  if (errstr_ == &::google::protobuf::internal::kEmptyString) {
    errstr_ = new ::std::string;
  }
  return errstr_;
}
inline ::std::string* Reply::release_errstr() {
  clear_has_errstr();
  if (errstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errstr_;
    errstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Reply::set_allocated_errstr(::std::string* errstr) {
  if (errstr_ != &::google::protobuf::internal::kEmptyString) {
    delete errstr_;
  }
  if (errstr) {
    set_has_errstr();
    errstr_ = errstr;
  } else {
    clear_has_errstr();
    errstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pool.proto.ServerInfo sinfo = 20;
inline bool Reply::has_sinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Reply::set_has_sinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Reply::clear_has_sinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Reply::clear_sinfo() {
  if (sinfo_ != NULL) sinfo_->::pool::proto::ServerInfo::Clear();
  clear_has_sinfo();
}
inline const ::pool::proto::ServerInfo& Reply::sinfo() const {
  return sinfo_ != NULL ? *sinfo_ : *default_instance_->sinfo_;
}
inline ::pool::proto::ServerInfo* Reply::mutable_sinfo() {
  set_has_sinfo();
  if (sinfo_ == NULL) sinfo_ = new ::pool::proto::ServerInfo;
  return sinfo_;
}
inline ::pool::proto::ServerInfo* Reply::release_sinfo() {
  clear_has_sinfo();
  ::pool::proto::ServerInfo* temp = sinfo_;
  sinfo_ = NULL;
  return temp;
}
inline void Reply::set_allocated_sinfo(::pool::proto::ServerInfo* sinfo) {
  delete sinfo_;
  sinfo_ = sinfo;
  if (sinfo) {
    set_has_sinfo();
  } else {
    clear_has_sinfo();
  }
}

// optional .pool.proto.Work work = 21;
inline bool Reply::has_work() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Reply::set_has_work() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Reply::clear_has_work() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Reply::clear_work() {
  if (work_ != NULL) work_->::pool::proto::Work::Clear();
  clear_has_work();
}
inline const ::pool::proto::Work& Reply::work() const {
  return work_ != NULL ? *work_ : *default_instance_->work_;
}
inline ::pool::proto::Work* Reply::mutable_work() {
  set_has_work();
  if (work_ == NULL) work_ = new ::pool::proto::Work;
  return work_;
}
inline ::pool::proto::Work* Reply::release_work() {
  clear_has_work();
  ::pool::proto::Work* temp = work_;
  work_ = NULL;
  return temp;
}
inline void Reply::set_allocated_work(::pool::proto::Work* work) {
  delete work_;
  work_ = work;
  if (work) {
    set_has_work();
  } else {
    clear_has_work();
  }
}

// optional .pool.proto.Block block = 22;
inline bool Reply::has_block() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Reply::set_has_block() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Reply::clear_has_block() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Reply::clear_block() {
  if (block_ != NULL) block_->::pool::proto::Block::Clear();
  clear_has_block();
}
inline const ::pool::proto::Block& Reply::block() const {
  return block_ != NULL ? *block_ : *default_instance_->block_;
}
inline ::pool::proto::Block* Reply::mutable_block() {
  set_has_block();
  if (block_ == NULL) block_ = new ::pool::proto::Block;
  return block_;
}
inline ::pool::proto::Block* Reply::release_block() {
  clear_has_block();
  ::pool::proto::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void Reply::set_allocated_block(::pool::proto::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
}

// -------------------------------------------------------------------

// ReqStats

// required .pool.proto.Request.Type reqtype = 1;
inline bool ReqStats::has_reqtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqStats::set_has_reqtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqStats::clear_has_reqtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqStats::clear_reqtype() {
  reqtype_ = 0;
  clear_has_reqtype();
}
inline ::pool::proto::Request_Type ReqStats::reqtype() const {
  return static_cast< ::pool::proto::Request_Type >(reqtype_);
}
inline void ReqStats::set_reqtype(::pool::proto::Request_Type value) {
  assert(::pool::proto::Request_Type_IsValid(value));
  set_has_reqtype();
  reqtype_ = value;
}

// required .pool.proto.Reply.ErrType errtype = 2;
inline bool ReqStats::has_errtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqStats::set_has_errtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqStats::clear_has_errtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqStats::clear_errtype() {
  errtype_ = 0;
  clear_has_errtype();
}
inline ::pool::proto::Reply_ErrType ReqStats::errtype() const {
  return static_cast< ::pool::proto::Reply_ErrType >(errtype_);
}
inline void ReqStats::set_errtype(::pool::proto::Reply_ErrType value) {
  assert(::pool::proto::Reply_ErrType_IsValid(value));
  set_has_errtype();
  errtype_ = value;
}

// required uint32 count = 3;
inline bool ReqStats::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqStats::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqStats::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqStats::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 ReqStats::count() const {
  return count_;
}
inline void ReqStats::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// ServerStats

// required string name = 1;
inline bool ServerStats::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerStats::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerStats::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerStats::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ServerStats::name() const {
  return *name_;
}
inline void ServerStats::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ServerStats::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ServerStats::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerStats::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ServerStats::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerStats::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 thread = 2;
inline bool ServerStats::has_thread() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerStats::set_has_thread() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerStats::clear_has_thread() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerStats::clear_thread() {
  thread_ = 0u;
  clear_has_thread();
}
inline ::google::protobuf::uint32 ServerStats::thread() const {
  return thread_;
}
inline void ServerStats::set_thread(::google::protobuf::uint32 value) {
  set_has_thread();
  thread_ = value;
}

// required uint32 workers = 10;
inline bool ServerStats::has_workers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerStats::set_has_workers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerStats::clear_has_workers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerStats::clear_workers() {
  workers_ = 0u;
  clear_has_workers();
}
inline ::google::protobuf::uint32 ServerStats::workers() const {
  return workers_;
}
inline void ServerStats::set_workers(::google::protobuf::uint32 value) {
  set_has_workers();
  workers_ = value;
}

// required uint32 latency = 11;
inline bool ServerStats::has_latency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerStats::set_has_latency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerStats::clear_has_latency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerStats::clear_latency() {
  latency_ = 0u;
  clear_has_latency();
}
inline ::google::protobuf::uint32 ServerStats::latency() const {
  return latency_;
}
inline void ServerStats::set_latency(::google::protobuf::uint32 value) {
  set_has_latency();
  latency_ = value;
}

// required float cpd = 12;
inline bool ServerStats::has_cpd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerStats::set_has_cpd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerStats::clear_has_cpd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerStats::clear_cpd() {
  cpd_ = 0;
  clear_has_cpd();
}
inline float ServerStats::cpd() const {
  return cpd_;
}
inline void ServerStats::set_cpd(float value) {
  set_has_cpd();
  cpd_ = value;
}

// repeated .pool.proto.ReqStats reqstats = 20;
inline int ServerStats::reqstats_size() const {
  return reqstats_.size();
}
inline void ServerStats::clear_reqstats() {
  reqstats_.Clear();
}
inline const ::pool::proto::ReqStats& ServerStats::reqstats(int index) const {
  return reqstats_.Get(index);
}
inline ::pool::proto::ReqStats* ServerStats::mutable_reqstats(int index) {
  return reqstats_.Mutable(index);
}
inline ::pool::proto::ReqStats* ServerStats::add_reqstats() {
  return reqstats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >&
ServerStats::reqstats() const {
  return reqstats_;
}
inline ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >*
ServerStats::mutable_reqstats() {
  return &reqstats_;
}

// -------------------------------------------------------------------

// Data

// optional .pool.proto.Share share = 1;
inline bool Data::has_share() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data::set_has_share() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data::clear_has_share() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data::clear_share() {
  if (share_ != NULL) share_->::pool::proto::Share::Clear();
  clear_has_share();
}
inline const ::pool::proto::Share& Data::share() const {
  return share_ != NULL ? *share_ : *default_instance_->share_;
}
inline ::pool::proto::Share* Data::mutable_share() {
  set_has_share();
  if (share_ == NULL) share_ = new ::pool::proto::Share;
  return share_;
}
inline ::pool::proto::Share* Data::release_share() {
  clear_has_share();
  ::pool::proto::Share* temp = share_;
  share_ = NULL;
  return temp;
}
inline void Data::set_allocated_share(::pool::proto::Share* share) {
  delete share_;
  share_ = share;
  if (share) {
    set_has_share();
  } else {
    clear_has_share();
  }
}

// optional .pool.proto.ClientStats clientstats = 2;
inline bool Data::has_clientstats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data::set_has_clientstats() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data::clear_has_clientstats() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data::clear_clientstats() {
  if (clientstats_ != NULL) clientstats_->::pool::proto::ClientStats::Clear();
  clear_has_clientstats();
}
inline const ::pool::proto::ClientStats& Data::clientstats() const {
  return clientstats_ != NULL ? *clientstats_ : *default_instance_->clientstats_;
}
inline ::pool::proto::ClientStats* Data::mutable_clientstats() {
  set_has_clientstats();
  if (clientstats_ == NULL) clientstats_ = new ::pool::proto::ClientStats;
  return clientstats_;
}
inline ::pool::proto::ClientStats* Data::release_clientstats() {
  clear_has_clientstats();
  ::pool::proto::ClientStats* temp = clientstats_;
  clientstats_ = NULL;
  return temp;
}
inline void Data::set_allocated_clientstats(::pool::proto::ClientStats* clientstats) {
  delete clientstats_;
  clientstats_ = clientstats;
  if (clientstats) {
    set_has_clientstats();
  } else {
    clear_has_clientstats();
  }
}

// optional .pool.proto.ServerStats serverstats = 3;
inline bool Data::has_serverstats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Data::set_has_serverstats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Data::clear_has_serverstats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Data::clear_serverstats() {
  if (serverstats_ != NULL) serverstats_->::pool::proto::ServerStats::Clear();
  clear_has_serverstats();
}
inline const ::pool::proto::ServerStats& Data::serverstats() const {
  return serverstats_ != NULL ? *serverstats_ : *default_instance_->serverstats_;
}
inline ::pool::proto::ServerStats* Data::mutable_serverstats() {
  set_has_serverstats();
  if (serverstats_ == NULL) serverstats_ = new ::pool::proto::ServerStats;
  return serverstats_;
}
inline ::pool::proto::ServerStats* Data::release_serverstats() {
  clear_has_serverstats();
  ::pool::proto::ServerStats* temp = serverstats_;
  serverstats_ = NULL;
  return temp;
}
inline void Data::set_allocated_serverstats(::pool::proto::ServerStats* serverstats) {
  delete serverstats_;
  serverstats_ = serverstats;
  if (serverstats) {
    set_has_serverstats();
  } else {
    clear_has_serverstats();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace pool

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pool::proto::Signal_Type>() {
  return ::pool::proto::Signal_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pool::proto::Request_Type>() {
  return ::pool::proto::Request_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pool::proto::Reply_ErrType>() {
  return ::pool::proto::Reply_ErrType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocol_2eproto__INCLUDED
