// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_INCLUDED_protocol_2eproto
#define PROTOBUF_INCLUDED_protocol_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protocol_2eproto 

namespace protobuf_protocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_protocol_2eproto
namespace pool {
namespace proto {
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class ClientStats;
class ClientStatsDefaultTypeInternal;
extern ClientStatsDefaultTypeInternal _ClientStats_default_instance_;
class Data;
class DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class Reply;
class ReplyDefaultTypeInternal;
extern ReplyDefaultTypeInternal _Reply_default_instance_;
class ReqStats;
class ReqStatsDefaultTypeInternal;
extern ReqStatsDefaultTypeInternal _ReqStats_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class ServerInfo;
class ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class ServerStats;
class ServerStatsDefaultTypeInternal;
extern ServerStatsDefaultTypeInternal _ServerStats_default_instance_;
class Share;
class ShareDefaultTypeInternal;
extern ShareDefaultTypeInternal _Share_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Work;
class WorkDefaultTypeInternal;
extern WorkDefaultTypeInternal _Work_default_instance_;
}  // namespace proto
}  // namespace pool
namespace google {
namespace protobuf {
template<> ::pool::proto::Block* Arena::CreateMaybeMessage<::pool::proto::Block>(Arena*);
template<> ::pool::proto::ClientStats* Arena::CreateMaybeMessage<::pool::proto::ClientStats>(Arena*);
template<> ::pool::proto::Data* Arena::CreateMaybeMessage<::pool::proto::Data>(Arena*);
template<> ::pool::proto::Reply* Arena::CreateMaybeMessage<::pool::proto::Reply>(Arena*);
template<> ::pool::proto::ReqStats* Arena::CreateMaybeMessage<::pool::proto::ReqStats>(Arena*);
template<> ::pool::proto::Request* Arena::CreateMaybeMessage<::pool::proto::Request>(Arena*);
template<> ::pool::proto::ServerInfo* Arena::CreateMaybeMessage<::pool::proto::ServerInfo>(Arena*);
template<> ::pool::proto::ServerStats* Arena::CreateMaybeMessage<::pool::proto::ServerStats>(Arena*);
template<> ::pool::proto::Share* Arena::CreateMaybeMessage<::pool::proto::Share>(Arena*);
template<> ::pool::proto::Signal* Arena::CreateMaybeMessage<::pool::proto::Signal>(Arena*);
template<> ::pool::proto::Work* Arena::CreateMaybeMessage<::pool::proto::Work>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pool {
namespace proto {

enum Signal_Type {
  Signal_Type_NEWBLOCK = 1,
  Signal_Type_SHUTDOWN = 2
};
bool Signal_Type_IsValid(int value);
const Signal_Type Signal_Type_Type_MIN = Signal_Type_NEWBLOCK;
const Signal_Type Signal_Type_Type_MAX = Signal_Type_SHUTDOWN;
const int Signal_Type_Type_ARRAYSIZE = Signal_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signal_Type_descriptor();
inline const ::std::string& Signal_Type_Name(Signal_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signal_Type_descriptor(), value);
}
inline bool Signal_Type_Parse(
    const ::std::string& name, Signal_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signal_Type>(
    Signal_Type_descriptor(), name, value);
}
enum Request_Type {
  Request_Type_NONE = 0,
  Request_Type_CONNECT = 1,
  Request_Type_GETWORK = 2,
  Request_Type_SHARE = 3,
  Request_Type_STATS = 4,
  Request_Type_PING = 5
};
bool Request_Type_IsValid(int value);
const Request_Type Request_Type_Type_MIN = Request_Type_NONE;
const Request_Type Request_Type_Type_MAX = Request_Type_PING;
const int Request_Type_Type_ARRAYSIZE = Request_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_Type_descriptor();
inline const ::std::string& Request_Type_Name(Request_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_Type_descriptor(), value);
}
inline bool Request_Type_Parse(
    const ::std::string& name, Request_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_Type>(
    Request_Type_descriptor(), name, value);
}
enum Reply_ErrType {
  Reply_ErrType_NONE = 0,
  Reply_ErrType_VERSION = 1,
  Reply_ErrType_HEIGHT = 2,
  Reply_ErrType_REQNONCE = 3,
  Reply_ErrType_STALE = 4,
  Reply_ErrType_INVALID = 5,
  Reply_ErrType_DUPLICATE = 6
};
bool Reply_ErrType_IsValid(int value);
const Reply_ErrType Reply_ErrType_ErrType_MIN = Reply_ErrType_NONE;
const Reply_ErrType Reply_ErrType_ErrType_MAX = Reply_ErrType_DUPLICATE;
const int Reply_ErrType_ErrType_ARRAYSIZE = Reply_ErrType_ErrType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reply_ErrType_descriptor();
inline const ::std::string& Reply_ErrType_Name(Reply_ErrType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reply_ErrType_descriptor(), value);
}
inline bool Reply_ErrType_Parse(
    const ::std::string& name, Reply_ErrType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reply_ErrType>(
    Reply_ErrType_descriptor(), name, value);
}
// ===================================================================

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Block* other);
  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(NULL);
  }

  Block* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hash = 2;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // required string prevhash = 3;
  bool has_prevhash() const;
  void clear_prevhash();
  static const int kPrevhashFieldNumber = 3;
  const ::std::string& prevhash() const;
  void set_prevhash(const ::std::string& value);
  #if LANG_CXX11
  void set_prevhash(::std::string&& value);
  #endif
  void set_prevhash(const char* value);
  void set_prevhash(const char* value, size_t size);
  ::std::string* mutable_prevhash();
  ::std::string* release_prevhash();
  void set_allocated_prevhash(::std::string* prevhash);

  // required uint32 height = 1;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required uint32 reqdiff = 4;
  bool has_reqdiff() const;
  void clear_reqdiff();
  static const int kReqdiffFieldNumber = 4;
  ::google::protobuf::uint32 reqdiff() const;
  void set_reqdiff(::google::protobuf::uint32 value);

  // required uint32 minshare = 5;
  bool has_minshare() const;
  void clear_minshare();
  static const int kMinshareFieldNumber = 5;
  ::google::protobuf::uint32 minshare() const;
  void set_minshare(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.Block)
 private:
  void set_has_height();
  void clear_has_height();
  void set_has_hash();
  void clear_has_hash();
  void set_has_prevhash();
  void clear_has_prevhash();
  void set_has_reqdiff();
  void clear_has_reqdiff();
  void set_has_minshare();
  void clear_has_minshare();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr prevhash_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 reqdiff_;
  ::google::protobuf::uint32 minshare_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Signal* other);
  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return CreateMaybeMessage<Signal>(NULL);
  }

  Signal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Signal_Type Type;
  static const Type NEWBLOCK =
    Signal_Type_NEWBLOCK;
  static const Type SHUTDOWN =
    Signal_Type_SHUTDOWN;
  static inline bool Type_IsValid(int value) {
    return Signal_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Signal_Type_Type_MIN;
  static const Type Type_MAX =
    Signal_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Signal_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Signal_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Signal_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Signal_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pool.proto.Block block = 2;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 2;
  private:
  const ::pool::proto::Block& _internal_block() const;
  public:
  const ::pool::proto::Block& block() const;
  ::pool::proto::Block* release_block();
  ::pool::proto::Block* mutable_block();
  void set_allocated_block(::pool::proto::Block* block);

  // required .pool.proto.Signal.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::pool::proto::Signal_Type type() const;
  void set_type(::pool::proto::Signal_Type value);

  // @@protoc_insertion_point(class_scope:pool.proto.Signal)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_block();
  void clear_has_block();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::pool::proto::Block* block_;
  int type_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.ClientStats) */ {
 public:
  ClientStats();
  virtual ~ClientStats();

  ClientStats(const ClientStats& from);

  inline ClientStats& operator=(const ClientStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientStats(ClientStats&& from) noexcept
    : ClientStats() {
    *this = ::std::move(from);
  }

  inline ClientStats& operator=(ClientStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientStats* internal_default_instance() {
    return reinterpret_cast<const ClientStats*>(
               &_ClientStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ClientStats* other);
  friend void swap(ClientStats& a, ClientStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientStats* New() const final {
    return CreateMaybeMessage<ClientStats>(NULL);
  }

  ClientStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientStats& from);
  void MergeFrom(const ClientStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_addr(::std::string&& value);
  #endif
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required fixed64 clientid = 3;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientidFieldNumber = 3;
  ::google::protobuf::uint64 clientid() const;
  void set_clientid(::google::protobuf::uint64 value);

  // required fixed64 instanceid = 4;
  bool has_instanceid() const;
  void clear_instanceid();
  static const int kInstanceidFieldNumber = 4;
  ::google::protobuf::uint64 instanceid() const;
  void set_instanceid(::google::protobuf::uint64 value);

  // required uint32 version = 10;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 10;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // required float cpd = 11;
  bool has_cpd() const;
  void clear_cpd();
  static const int kCpdFieldNumber = 11;
  float cpd() const;
  void set_cpd(float value);

  // required uint32 height = 16;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 16;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required uint32 latency = 12;
  bool has_latency() const;
  void clear_latency();
  static const int kLatencyFieldNumber = 12;
  ::google::protobuf::uint32 latency() const;
  void set_latency(::google::protobuf::uint32 value);

  // required uint32 temp = 13;
  bool has_temp() const;
  void clear_temp();
  static const int kTempFieldNumber = 13;
  ::google::protobuf::uint32 temp() const;
  void set_temp(::google::protobuf::uint32 value);

  // required uint32 errors = 14;
  bool has_errors() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 14;
  ::google::protobuf::uint32 errors() const;
  void set_errors(::google::protobuf::uint32 value);

  // required uint32 ngpus = 15;
  bool has_ngpus() const;
  void clear_ngpus();
  static const int kNgpusFieldNumber = 15;
  ::google::protobuf::uint32 ngpus() const;
  void set_ngpus(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.ClientStats)
 private:
  void set_has_addr();
  void clear_has_addr();
  void set_has_name();
  void clear_has_name();
  void set_has_clientid();
  void clear_has_clientid();
  void set_has_instanceid();
  void clear_has_instanceid();
  void set_has_version();
  void clear_has_version();
  void set_has_cpd();
  void clear_has_cpd();
  void set_has_latency();
  void clear_has_latency();
  void set_has_temp();
  void clear_has_temp();
  void set_has_errors();
  void clear_has_errors();
  void set_has_ngpus();
  void clear_has_ngpus();
  void set_has_height();
  void clear_has_height();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 clientid_;
  ::google::protobuf::uint64 instanceid_;
  ::google::protobuf::uint32 version_;
  float cpd_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 latency_;
  ::google::protobuf::uint32 temp_;
  ::google::protobuf::uint32 errors_;
  ::google::protobuf::uint32 ngpus_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Share : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Share) */ {
 public:
  Share();
  virtual ~Share();

  Share(const Share& from);

  inline Share& operator=(const Share& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Share(Share&& from) noexcept
    : Share() {
    *this = ::std::move(from);
  }

  inline Share& operator=(Share&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Share& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Share* internal_default_instance() {
    return reinterpret_cast<const Share*>(
               &_Share_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Share* other);
  friend void swap(Share& a, Share& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Share* New() const final {
    return CreateMaybeMessage<Share>(NULL);
  }

  Share* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Share>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Share& from);
  void MergeFrom(const Share& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Share* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_addr(::std::string&& value);
  #endif
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string hash = 10;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 10;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // required string merkle = 11;
  bool has_merkle() const;
  void clear_merkle();
  static const int kMerkleFieldNumber = 11;
  const ::std::string& merkle() const;
  void set_merkle(const ::std::string& value);
  #if LANG_CXX11
  void set_merkle(::std::string&& value);
  #endif
  void set_merkle(const char* value);
  void set_merkle(const char* value, size_t size);
  ::std::string* mutable_merkle();
  ::std::string* release_merkle();
  void set_allocated_merkle(::std::string* merkle);

  // required string multi = 15;
  bool has_multi() const;
  void clear_multi();
  static const int kMultiFieldNumber = 15;
  const ::std::string& multi() const;
  void set_multi(const ::std::string& value);
  #if LANG_CXX11
  void set_multi(::std::string&& value);
  #endif
  void set_multi(const char* value);
  void set_multi(const char* value, size_t size);
  ::std::string* mutable_multi();
  ::std::string* release_multi();
  void set_allocated_multi(::std::string* multi);

  // optional string blockhash = 16;
  bool has_blockhash() const;
  void clear_blockhash();
  static const int kBlockhashFieldNumber = 16;
  const ::std::string& blockhash() const;
  void set_blockhash(const ::std::string& value);
  #if LANG_CXX11
  void set_blockhash(::std::string&& value);
  #endif
  void set_blockhash(const char* value);
  void set_blockhash(const char* value, size_t size);
  ::std::string* mutable_blockhash();
  ::std::string* release_blockhash();
  void set_allocated_blockhash(::std::string* blockhash);

  // required fixed64 clientid = 3;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientidFieldNumber = 3;
  ::google::protobuf::uint64 clientid() const;
  void set_clientid(::google::protobuf::uint64 value);

  // optional uint32 gpuid = 4;
  bool has_gpuid() const;
  void clear_gpuid();
  static const int kGpuidFieldNumber = 4;
  ::google::protobuf::uint32 gpuid() const;
  void set_gpuid(::google::protobuf::uint32 value);

  // required uint32 time = 12;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 12;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // required uint32 bits = 13;
  bool has_bits() const;
  void clear_bits();
  static const int kBitsFieldNumber = 13;
  ::google::protobuf::uint32 bits() const;
  void set_bits(::google::protobuf::uint32 value);

  // required uint32 nonce = 14;
  bool has_nonce() const;
  void clear_nonce();
  static const int kNonceFieldNumber = 14;
  ::google::protobuf::uint32 nonce() const;
  void set_nonce(::google::protobuf::uint32 value);

  // required uint32 height = 20;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 20;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required uint32 length = 21;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 21;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // required uint32 chaintype = 22;
  bool has_chaintype() const;
  void clear_chaintype();
  static const int kChaintypeFieldNumber = 22;
  ::google::protobuf::uint32 chaintype() const;
  void set_chaintype(::google::protobuf::uint32 value);

  // required bool isblock = 23;
  bool has_isblock() const;
  void clear_isblock();
  static const int kIsblockFieldNumber = 23;
  bool isblock() const;
  void set_isblock(bool value);

  // optional uint64 genvalue = 24;
  bool has_genvalue() const;
  void clear_genvalue();
  static const int kGenvalueFieldNumber = 24;
  ::google::protobuf::uint64 genvalue() const;
  void set_genvalue(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pool.proto.Share)
 private:
  void set_has_addr();
  void clear_has_addr();
  void set_has_name();
  void clear_has_name();
  void set_has_clientid();
  void clear_has_clientid();
  void set_has_gpuid();
  void clear_has_gpuid();
  void set_has_hash();
  void clear_has_hash();
  void set_has_merkle();
  void clear_has_merkle();
  void set_has_time();
  void clear_has_time();
  void set_has_bits();
  void clear_has_bits();
  void set_has_nonce();
  void clear_has_nonce();
  void set_has_multi();
  void clear_has_multi();
  void set_has_blockhash();
  void clear_has_blockhash();
  void set_has_height();
  void clear_has_height();
  void set_has_length();
  void clear_has_length();
  void set_has_chaintype();
  void clear_has_chaintype();
  void set_has_isblock();
  void clear_has_isblock();
  void set_has_genvalue();
  void clear_has_genvalue();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr merkle_;
  ::google::protobuf::internal::ArenaStringPtr multi_;
  ::google::protobuf::internal::ArenaStringPtr blockhash_;
  ::google::protobuf::uint64 clientid_;
  ::google::protobuf::uint32 gpuid_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 bits_;
  ::google::protobuf::uint32 nonce_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 length_;
  ::google::protobuf::uint32 chaintype_;
  bool isblock_;
  ::google::protobuf::uint64 genvalue_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(NULL);
  }

  Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Request_Type Type;
  static const Type NONE =
    Request_Type_NONE;
  static const Type CONNECT =
    Request_Type_CONNECT;
  static const Type GETWORK =
    Request_Type_GETWORK;
  static const Type SHARE =
    Request_Type_SHARE;
  static const Type STATS =
    Request_Type_STATS;
  static const Type PING =
    Request_Type_PING;
  static inline bool Type_IsValid(int value) {
    return Request_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Request_Type_Type_MIN;
  static const Type Type_MAX =
    Request_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Request_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Request_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Request_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Request_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes reqnonce = 12;
  bool has_reqnonce() const;
  void clear_reqnonce();
  static const int kReqnonceFieldNumber = 12;
  const ::std::string& reqnonce() const;
  void set_reqnonce(const ::std::string& value);
  #if LANG_CXX11
  void set_reqnonce(::std::string&& value);
  #endif
  void set_reqnonce(const char* value);
  void set_reqnonce(const void* value, size_t size);
  ::std::string* mutable_reqnonce();
  ::std::string* release_reqnonce();
  void set_allocated_reqnonce(::std::string* reqnonce);

  // optional .pool.proto.Share share = 20;
  bool has_share() const;
  void clear_share();
  static const int kShareFieldNumber = 20;
  private:
  const ::pool::proto::Share& _internal_share() const;
  public:
  const ::pool::proto::Share& share() const;
  ::pool::proto::Share* release_share();
  ::pool::proto::Share* mutable_share();
  void set_allocated_share(::pool::proto::Share* share);

  // optional .pool.proto.ClientStats stats = 21;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 21;
  private:
  const ::pool::proto::ClientStats& _internal_stats() const;
  public:
  const ::pool::proto::ClientStats& stats() const;
  ::pool::proto::ClientStats* release_stats();
  ::pool::proto::ClientStats* mutable_stats();
  void set_allocated_stats(::pool::proto::ClientStats* stats);

  // required .pool.proto.Request.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::pool::proto::Request_Type type() const;
  void set_type(::pool::proto::Request_Type value);

  // required uint32 reqid = 2;
  bool has_reqid() const;
  void clear_reqid();
  static const int kReqidFieldNumber = 2;
  ::google::protobuf::uint32 reqid() const;
  void set_reqid(::google::protobuf::uint32 value);

  // optional uint32 version = 10;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 10;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional uint32 height = 11;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 11;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.Request)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_reqid();
  void clear_has_reqid();
  void set_has_version();
  void clear_has_version();
  void set_has_height();
  void clear_has_height();
  void set_has_reqnonce();
  void clear_has_reqnonce();
  void set_has_share();
  void clear_has_share();
  void set_has_stats();
  void clear_has_stats();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reqnonce_;
  ::pool::proto::Share* share_;
  ::pool::proto::ClientStats* stats_;
  int type_;
  ::google::protobuf::uint32 reqid_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 height_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.ServerInfo) */ {
 public:
  ServerInfo();
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ServerInfo* other);
  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerInfo* New() const final {
    return CreateMaybeMessage<ServerInfo>(NULL);
  }

  ServerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string host = 1;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 1;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // required uint32 router = 2;
  bool has_router() const;
  void clear_router();
  static const int kRouterFieldNumber = 2;
  ::google::protobuf::uint32 router() const;
  void set_router(::google::protobuf::uint32 value);

  // required uint32 pub = 3;
  bool has_pub() const;
  void clear_pub();
  static const int kPubFieldNumber = 3;
  ::google::protobuf::uint32 pub() const;
  void set_pub(::google::protobuf::uint32 value);

  // required uint32 target = 4;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 4;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.ServerInfo)
 private:
  void set_has_host();
  void clear_has_host();
  void set_has_router();
  void clear_has_router();
  void set_has_pub();
  void clear_has_pub();
  void set_has_target();
  void clear_has_target();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::uint32 router_;
  ::google::protobuf::uint32 pub_;
  ::google::protobuf::uint32 target_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Work : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Work) */ {
 public:
  Work();
  virtual ~Work();

  Work(const Work& from);

  inline Work& operator=(const Work& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Work(Work&& from) noexcept
    : Work() {
    *this = ::std::move(from);
  }

  inline Work& operator=(Work&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Work& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Work* internal_default_instance() {
    return reinterpret_cast<const Work*>(
               &_Work_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Work* other);
  friend void swap(Work& a, Work& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Work* New() const final {
    return CreateMaybeMessage<Work>(NULL);
  }

  Work* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Work>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Work& from);
  void MergeFrom(const Work& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Work* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string merkle = 2;
  bool has_merkle() const;
  void clear_merkle();
  static const int kMerkleFieldNumber = 2;
  const ::std::string& merkle() const;
  void set_merkle(const ::std::string& value);
  #if LANG_CXX11
  void set_merkle(::std::string&& value);
  #endif
  void set_merkle(const char* value);
  void set_merkle(const char* value, size_t size);
  ::std::string* mutable_merkle();
  ::std::string* release_merkle();
  void set_allocated_merkle(::std::string* merkle);

  // required uint32 height = 1;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required uint32 time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // required uint32 bits = 4;
  bool has_bits() const;
  void clear_bits();
  static const int kBitsFieldNumber = 4;
  ::google::protobuf::uint32 bits() const;
  void set_bits(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.Work)
 private:
  void set_has_height();
  void clear_has_height();
  void set_has_merkle();
  void clear_has_merkle();
  void set_has_time();
  void clear_has_time();
  void set_has_bits();
  void clear_has_bits();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr merkle_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 bits_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Reply) */ {
 public:
  Reply();
  virtual ~Reply();

  Reply(const Reply& from);

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reply(Reply&& from) noexcept
    : Reply() {
    *this = ::std::move(from);
  }

  inline Reply& operator=(Reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reply* internal_default_instance() {
    return reinterpret_cast<const Reply*>(
               &_Reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Reply* other);
  friend void swap(Reply& a, Reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reply* New() const final {
    return CreateMaybeMessage<Reply>(NULL);
  }

  Reply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Reply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Reply& from);
  void MergeFrom(const Reply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Reply_ErrType ErrType;
  static const ErrType NONE =
    Reply_ErrType_NONE;
  static const ErrType VERSION =
    Reply_ErrType_VERSION;
  static const ErrType HEIGHT =
    Reply_ErrType_HEIGHT;
  static const ErrType REQNONCE =
    Reply_ErrType_REQNONCE;
  static const ErrType STALE =
    Reply_ErrType_STALE;
  static const ErrType INVALID =
    Reply_ErrType_INVALID;
  static const ErrType DUPLICATE =
    Reply_ErrType_DUPLICATE;
  static inline bool ErrType_IsValid(int value) {
    return Reply_ErrType_IsValid(value);
  }
  static const ErrType ErrType_MIN =
    Reply_ErrType_ErrType_MIN;
  static const ErrType ErrType_MAX =
    Reply_ErrType_ErrType_MAX;
  static const int ErrType_ARRAYSIZE =
    Reply_ErrType_ErrType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrType_descriptor() {
    return Reply_ErrType_descriptor();
  }
  static inline const ::std::string& ErrType_Name(ErrType value) {
    return Reply_ErrType_Name(value);
  }
  static inline bool ErrType_Parse(const ::std::string& name,
      ErrType* value) {
    return Reply_ErrType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string errstr = 11;
  bool has_errstr() const;
  void clear_errstr();
  static const int kErrstrFieldNumber = 11;
  const ::std::string& errstr() const;
  void set_errstr(const ::std::string& value);
  #if LANG_CXX11
  void set_errstr(::std::string&& value);
  #endif
  void set_errstr(const char* value);
  void set_errstr(const char* value, size_t size);
  ::std::string* mutable_errstr();
  ::std::string* release_errstr();
  void set_allocated_errstr(::std::string* errstr);

  // optional .pool.proto.ServerInfo sinfo = 20;
  bool has_sinfo() const;
  void clear_sinfo();
  static const int kSinfoFieldNumber = 20;
  private:
  const ::pool::proto::ServerInfo& _internal_sinfo() const;
  public:
  const ::pool::proto::ServerInfo& sinfo() const;
  ::pool::proto::ServerInfo* release_sinfo();
  ::pool::proto::ServerInfo* mutable_sinfo();
  void set_allocated_sinfo(::pool::proto::ServerInfo* sinfo);

  // optional .pool.proto.Work work = 21;
  bool has_work() const;
  void clear_work();
  static const int kWorkFieldNumber = 21;
  private:
  const ::pool::proto::Work& _internal_work() const;
  public:
  const ::pool::proto::Work& work() const;
  ::pool::proto::Work* release_work();
  ::pool::proto::Work* mutable_work();
  void set_allocated_work(::pool::proto::Work* work);

  // optional .pool.proto.Block block = 22;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 22;
  private:
  const ::pool::proto::Block& _internal_block() const;
  public:
  const ::pool::proto::Block& block() const;
  ::pool::proto::Block* release_block();
  ::pool::proto::Block* mutable_block();
  void set_allocated_block(::pool::proto::Block* block);

  // required .pool.proto.Request.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::pool::proto::Request_Type type() const;
  void set_type(::pool::proto::Request_Type value);

  // required uint32 reqid = 2;
  bool has_reqid() const;
  void clear_reqid();
  static const int kReqidFieldNumber = 2;
  ::google::protobuf::uint32 reqid() const;
  void set_reqid(::google::protobuf::uint32 value);

  // required .pool.proto.Reply.ErrType error = 10;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 10;
  ::pool::proto::Reply_ErrType error() const;
  void set_error(::pool::proto::Reply_ErrType value);

  // @@protoc_insertion_point(class_scope:pool.proto.Reply)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_reqid();
  void clear_has_reqid();
  void set_has_error();
  void clear_has_error();
  void set_has_errstr();
  void clear_has_errstr();
  void set_has_sinfo();
  void clear_has_sinfo();
  void set_has_work();
  void clear_has_work();
  void set_has_block();
  void clear_has_block();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errstr_;
  ::pool::proto::ServerInfo* sinfo_;
  ::pool::proto::Work* work_;
  ::pool::proto::Block* block_;
  int type_;
  ::google::protobuf::uint32 reqid_;
  int error_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReqStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.ReqStats) */ {
 public:
  ReqStats();
  virtual ~ReqStats();

  ReqStats(const ReqStats& from);

  inline ReqStats& operator=(const ReqStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqStats(ReqStats&& from) noexcept
    : ReqStats() {
    *this = ::std::move(from);
  }

  inline ReqStats& operator=(ReqStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqStats* internal_default_instance() {
    return reinterpret_cast<const ReqStats*>(
               &_ReqStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ReqStats* other);
  friend void swap(ReqStats& a, ReqStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqStats* New() const final {
    return CreateMaybeMessage<ReqStats>(NULL);
  }

  ReqStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqStats& from);
  void MergeFrom(const ReqStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pool.proto.Request.Type reqtype = 1;
  bool has_reqtype() const;
  void clear_reqtype();
  static const int kReqtypeFieldNumber = 1;
  ::pool::proto::Request_Type reqtype() const;
  void set_reqtype(::pool::proto::Request_Type value);

  // required .pool.proto.Reply.ErrType errtype = 2;
  bool has_errtype() const;
  void clear_errtype();
  static const int kErrtypeFieldNumber = 2;
  ::pool::proto::Reply_ErrType errtype() const;
  void set_errtype(::pool::proto::Reply_ErrType value);

  // required uint32 count = 3;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pool.proto.ReqStats)
 private:
  void set_has_reqtype();
  void clear_has_reqtype();
  void set_has_errtype();
  void clear_has_errtype();
  void set_has_count();
  void clear_has_count();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int reqtype_;
  int errtype_;
  ::google::protobuf::uint32 count_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.ServerStats) */ {
 public:
  ServerStats();
  virtual ~ServerStats();

  ServerStats(const ServerStats& from);

  inline ServerStats& operator=(const ServerStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerStats(ServerStats&& from) noexcept
    : ServerStats() {
    *this = ::std::move(from);
  }

  inline ServerStats& operator=(ServerStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerStats* internal_default_instance() {
    return reinterpret_cast<const ServerStats*>(
               &_ServerStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ServerStats* other);
  friend void swap(ServerStats& a, ServerStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerStats* New() const final {
    return CreateMaybeMessage<ServerStats>(NULL);
  }

  ServerStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerStats& from);
  void MergeFrom(const ServerStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pool.proto.ReqStats reqstats = 20;
  int reqstats_size() const;
  void clear_reqstats();
  static const int kReqstatsFieldNumber = 20;
  ::pool::proto::ReqStats* mutable_reqstats(int index);
  ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >*
      mutable_reqstats();
  const ::pool::proto::ReqStats& reqstats(int index) const;
  ::pool::proto::ReqStats* add_reqstats();
  const ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >&
      reqstats() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint32 thread = 2;
  bool has_thread() const;
  void clear_thread();
  static const int kThreadFieldNumber = 2;
  ::google::protobuf::uint32 thread() const;
  void set_thread(::google::protobuf::uint32 value);

  // required uint32 workers = 10;
  bool has_workers() const;
  void clear_workers();
  static const int kWorkersFieldNumber = 10;
  ::google::protobuf::uint32 workers() const;
  void set_workers(::google::protobuf::uint32 value);

  // required uint32 latency = 11;
  bool has_latency() const;
  void clear_latency();
  static const int kLatencyFieldNumber = 11;
  ::google::protobuf::uint32 latency() const;
  void set_latency(::google::protobuf::uint32 value);

  // required float cpd = 12;
  bool has_cpd() const;
  void clear_cpd();
  static const int kCpdFieldNumber = 12;
  float cpd() const;
  void set_cpd(float value);

  // @@protoc_insertion_point(class_scope:pool.proto.ServerStats)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_thread();
  void clear_has_thread();
  void set_has_workers();
  void clear_has_workers();
  void set_has_latency();
  void clear_has_latency();
  void set_has_cpd();
  void clear_has_cpd();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats > reqstats_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 thread_;
  ::google::protobuf::uint32 workers_;
  ::google::protobuf::uint32 latency_;
  float cpd_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pool.proto.Data) */ {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Data& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Data* other);
  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Data* New() const final {
    return CreateMaybeMessage<Data>(NULL);
  }

  Data* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pool.proto.Share share = 1;
  bool has_share() const;
  void clear_share();
  static const int kShareFieldNumber = 1;
  private:
  const ::pool::proto::Share& _internal_share() const;
  public:
  const ::pool::proto::Share& share() const;
  ::pool::proto::Share* release_share();
  ::pool::proto::Share* mutable_share();
  void set_allocated_share(::pool::proto::Share* share);

  // optional .pool.proto.ClientStats clientstats = 2;
  bool has_clientstats() const;
  void clear_clientstats();
  static const int kClientstatsFieldNumber = 2;
  private:
  const ::pool::proto::ClientStats& _internal_clientstats() const;
  public:
  const ::pool::proto::ClientStats& clientstats() const;
  ::pool::proto::ClientStats* release_clientstats();
  ::pool::proto::ClientStats* mutable_clientstats();
  void set_allocated_clientstats(::pool::proto::ClientStats* clientstats);

  // optional .pool.proto.ServerStats serverstats = 3;
  bool has_serverstats() const;
  void clear_serverstats();
  static const int kServerstatsFieldNumber = 3;
  private:
  const ::pool::proto::ServerStats& _internal_serverstats() const;
  public:
  const ::pool::proto::ServerStats& serverstats() const;
  ::pool::proto::ServerStats* release_serverstats();
  ::pool::proto::ServerStats* mutable_serverstats();
  void set_allocated_serverstats(::pool::proto::ServerStats* serverstats);

  // @@protoc_insertion_point(class_scope:pool.proto.Data)
 private:
  void set_has_share();
  void clear_has_share();
  void set_has_clientstats();
  void clear_has_clientstats();
  void set_has_serverstats();
  void clear_has_serverstats();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::pool::proto::Share* share_;
  ::pool::proto::ClientStats* clientstats_;
  ::pool::proto::ServerStats* serverstats_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Block

// required uint32 height = 1;
inline bool Block::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Block::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Block::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Block::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Block::height() const {
  // @@protoc_insertion_point(field_get:pool.proto.Block.height)
  return height_;
}
inline void Block::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Block.height)
}

// required string hash = 2;
inline bool Block::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Block::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Block::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Block::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& Block::hash() const {
  // @@protoc_insertion_point(field_get:pool.proto.Block.hash)
  return hash_.GetNoArena();
}
inline void Block::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Block.hash)
}
#if LANG_CXX11
inline void Block::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.Block.hash)
}
#endif
inline void Block::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Block.hash)
}
inline void Block::set_hash(const char* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Block.hash)
}
inline ::std::string* Block::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:pool.proto.Block.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_hash() {
  // @@protoc_insertion_point(field_release:pool.proto.Block.hash)
  if (!has_hash()) {
    return NULL;
  }
  clear_has_hash();
  return hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Block.hash)
}

// required string prevhash = 3;
inline bool Block::has_prevhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Block::set_has_prevhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Block::clear_has_prevhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Block::clear_prevhash() {
  prevhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prevhash();
}
inline const ::std::string& Block::prevhash() const {
  // @@protoc_insertion_point(field_get:pool.proto.Block.prevhash)
  return prevhash_.GetNoArena();
}
inline void Block::set_prevhash(const ::std::string& value) {
  set_has_prevhash();
  prevhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Block.prevhash)
}
#if LANG_CXX11
inline void Block::set_prevhash(::std::string&& value) {
  set_has_prevhash();
  prevhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.Block.prevhash)
}
#endif
inline void Block::set_prevhash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_prevhash();
  prevhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Block.prevhash)
}
inline void Block::set_prevhash(const char* value, size_t size) {
  set_has_prevhash();
  prevhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Block.prevhash)
}
inline ::std::string* Block::mutable_prevhash() {
  set_has_prevhash();
  // @@protoc_insertion_point(field_mutable:pool.proto.Block.prevhash)
  return prevhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_prevhash() {
  // @@protoc_insertion_point(field_release:pool.proto.Block.prevhash)
  if (!has_prevhash()) {
    return NULL;
  }
  clear_has_prevhash();
  return prevhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_prevhash(::std::string* prevhash) {
  if (prevhash != NULL) {
    set_has_prevhash();
  } else {
    clear_has_prevhash();
  }
  prevhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prevhash);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Block.prevhash)
}

// required uint32 reqdiff = 4;
inline bool Block::has_reqdiff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Block::set_has_reqdiff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Block::clear_has_reqdiff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Block::clear_reqdiff() {
  reqdiff_ = 0u;
  clear_has_reqdiff();
}
inline ::google::protobuf::uint32 Block::reqdiff() const {
  // @@protoc_insertion_point(field_get:pool.proto.Block.reqdiff)
  return reqdiff_;
}
inline void Block::set_reqdiff(::google::protobuf::uint32 value) {
  set_has_reqdiff();
  reqdiff_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Block.reqdiff)
}

// required uint32 minshare = 5;
inline bool Block::has_minshare() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Block::set_has_minshare() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Block::clear_has_minshare() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Block::clear_minshare() {
  minshare_ = 0u;
  clear_has_minshare();
}
inline ::google::protobuf::uint32 Block::minshare() const {
  // @@protoc_insertion_point(field_get:pool.proto.Block.minshare)
  return minshare_;
}
inline void Block::set_minshare(::google::protobuf::uint32 value) {
  set_has_minshare();
  minshare_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Block.minshare)
}

// -------------------------------------------------------------------

// Signal

// required .pool.proto.Signal.Type type = 1;
inline bool Signal::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Signal::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Signal::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pool::proto::Signal_Type Signal::type() const {
  // @@protoc_insertion_point(field_get:pool.proto.Signal.type)
  return static_cast< ::pool::proto::Signal_Type >(type_);
}
inline void Signal::set_type(::pool::proto::Signal_Type value) {
  assert(::pool::proto::Signal_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Signal.type)
}

// optional .pool.proto.Block block = 2;
inline bool Signal::has_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal::set_has_block() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signal::clear_has_block() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signal::clear_block() {
  if (block_ != NULL) block_->Clear();
  clear_has_block();
}
inline const ::pool::proto::Block& Signal::_internal_block() const {
  return *block_;
}
inline const ::pool::proto::Block& Signal::block() const {
  const ::pool::proto::Block* p = block_;
  // @@protoc_insertion_point(field_get:pool.proto.Signal.block)
  return p != NULL ? *p : *reinterpret_cast<const ::pool::proto::Block*>(
      &::pool::proto::_Block_default_instance_);
}
inline ::pool::proto::Block* Signal::release_block() {
  // @@protoc_insertion_point(field_release:pool.proto.Signal.block)
  clear_has_block();
  ::pool::proto::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline ::pool::proto::Block* Signal::mutable_block() {
  set_has_block();
  if (block_ == NULL) {
    auto* p = CreateMaybeMessage<::pool::proto::Block>(GetArenaNoVirtual());
    block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Signal.block)
  return block_;
}
inline void Signal::set_allocated_block(::pool::proto::Block* block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete block_;
  }
  if (block) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    set_has_block();
  } else {
    clear_has_block();
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Signal.block)
}

// -------------------------------------------------------------------

// ClientStats

// required string addr = 1;
inline bool ClientStats::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientStats::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientStats::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientStats::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_addr();
}
inline const ::std::string& ClientStats::addr() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.addr)
  return addr_.GetNoArena();
}
inline void ClientStats::set_addr(const ::std::string& value) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.addr)
}
#if LANG_CXX11
inline void ClientStats::set_addr(::std::string&& value) {
  set_has_addr();
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.ClientStats.addr)
}
#endif
inline void ClientStats::set_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.ClientStats.addr)
}
inline void ClientStats::set_addr(const char* value, size_t size) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.ClientStats.addr)
}
inline ::std::string* ClientStats::mutable_addr() {
  set_has_addr();
  // @@protoc_insertion_point(field_mutable:pool.proto.ClientStats.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientStats::release_addr() {
  // @@protoc_insertion_point(field_release:pool.proto.ClientStats.addr)
  if (!has_addr()) {
    return NULL;
  }
  clear_has_addr();
  return addr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientStats::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.ClientStats.addr)
}

// required string name = 2;
inline bool ClientStats::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientStats::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientStats::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientStats::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ClientStats::name() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.name)
  return name_.GetNoArena();
}
inline void ClientStats::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.name)
}
#if LANG_CXX11
inline void ClientStats::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.ClientStats.name)
}
#endif
inline void ClientStats::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.ClientStats.name)
}
inline void ClientStats::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.ClientStats.name)
}
inline ::std::string* ClientStats::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:pool.proto.ClientStats.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientStats::release_name() {
  // @@protoc_insertion_point(field_release:pool.proto.ClientStats.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientStats::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.ClientStats.name)
}

// required fixed64 clientid = 3;
inline bool ClientStats::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientStats::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientStats::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientStats::clear_clientid() {
  clientid_ = GOOGLE_ULONGLONG(0);
  clear_has_clientid();
}
inline ::google::protobuf::uint64 ClientStats::clientid() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.clientid)
  return clientid_;
}
inline void ClientStats::set_clientid(::google::protobuf::uint64 value) {
  set_has_clientid();
  clientid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.clientid)
}

// required fixed64 instanceid = 4;
inline bool ClientStats::has_instanceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientStats::set_has_instanceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientStats::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientStats::clear_instanceid() {
  instanceid_ = GOOGLE_ULONGLONG(0);
  clear_has_instanceid();
}
inline ::google::protobuf::uint64 ClientStats::instanceid() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.instanceid)
  return instanceid_;
}
inline void ClientStats::set_instanceid(::google::protobuf::uint64 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.instanceid)
}

// required uint32 version = 10;
inline bool ClientStats::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientStats::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientStats::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientStats::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 ClientStats::version() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.version)
  return version_;
}
inline void ClientStats::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.version)
}

// required float cpd = 11;
inline bool ClientStats::has_cpd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientStats::set_has_cpd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientStats::clear_has_cpd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientStats::clear_cpd() {
  cpd_ = 0;
  clear_has_cpd();
}
inline float ClientStats::cpd() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.cpd)
  return cpd_;
}
inline void ClientStats::set_cpd(float value) {
  set_has_cpd();
  cpd_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.cpd)
}

// required uint32 latency = 12;
inline bool ClientStats::has_latency() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientStats::set_has_latency() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientStats::clear_has_latency() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientStats::clear_latency() {
  latency_ = 0u;
  clear_has_latency();
}
inline ::google::protobuf::uint32 ClientStats::latency() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.latency)
  return latency_;
}
inline void ClientStats::set_latency(::google::protobuf::uint32 value) {
  set_has_latency();
  latency_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.latency)
}

// required uint32 temp = 13;
inline bool ClientStats::has_temp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientStats::set_has_temp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientStats::clear_has_temp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientStats::clear_temp() {
  temp_ = 0u;
  clear_has_temp();
}
inline ::google::protobuf::uint32 ClientStats::temp() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.temp)
  return temp_;
}
inline void ClientStats::set_temp(::google::protobuf::uint32 value) {
  set_has_temp();
  temp_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.temp)
}

// required uint32 errors = 14;
inline bool ClientStats::has_errors() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientStats::set_has_errors() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientStats::clear_has_errors() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientStats::clear_errors() {
  errors_ = 0u;
  clear_has_errors();
}
inline ::google::protobuf::uint32 ClientStats::errors() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.errors)
  return errors_;
}
inline void ClientStats::set_errors(::google::protobuf::uint32 value) {
  set_has_errors();
  errors_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.errors)
}

// required uint32 ngpus = 15;
inline bool ClientStats::has_ngpus() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientStats::set_has_ngpus() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientStats::clear_has_ngpus() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientStats::clear_ngpus() {
  ngpus_ = 0u;
  clear_has_ngpus();
}
inline ::google::protobuf::uint32 ClientStats::ngpus() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.ngpus)
  return ngpus_;
}
inline void ClientStats::set_ngpus(::google::protobuf::uint32 value) {
  set_has_ngpus();
  ngpus_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.ngpus)
}

// required uint32 height = 16;
inline bool ClientStats::has_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientStats::set_has_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientStats::clear_has_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientStats::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 ClientStats::height() const {
  // @@protoc_insertion_point(field_get:pool.proto.ClientStats.height)
  return height_;
}
inline void ClientStats::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ClientStats.height)
}

// -------------------------------------------------------------------

// Share

// required string addr = 1;
inline bool Share::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Share::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Share::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Share::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_addr();
}
inline const ::std::string& Share::addr() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.addr)
  return addr_.GetNoArena();
}
inline void Share::set_addr(const ::std::string& value) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.addr)
}
#if LANG_CXX11
inline void Share::set_addr(::std::string&& value) {
  set_has_addr();
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.Share.addr)
}
#endif
inline void Share::set_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.addr)
}
inline void Share::set_addr(const char* value, size_t size) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.addr)
}
inline ::std::string* Share::mutable_addr() {
  set_has_addr();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_addr() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.addr)
  if (!has_addr()) {
    return NULL;
  }
  clear_has_addr();
  return addr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.addr)
}

// required string name = 2;
inline bool Share::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Share::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Share::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Share::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Share::name() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.name)
  return name_.GetNoArena();
}
inline void Share::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.name)
}
#if LANG_CXX11
inline void Share::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.Share.name)
}
#endif
inline void Share::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.name)
}
inline void Share::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.name)
}
inline ::std::string* Share::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_name() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.name)
}

// required fixed64 clientid = 3;
inline bool Share::has_clientid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Share::set_has_clientid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Share::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Share::clear_clientid() {
  clientid_ = GOOGLE_ULONGLONG(0);
  clear_has_clientid();
}
inline ::google::protobuf::uint64 Share::clientid() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.clientid)
  return clientid_;
}
inline void Share::set_clientid(::google::protobuf::uint64 value) {
  set_has_clientid();
  clientid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.clientid)
}

// optional uint32 gpuid = 4;
inline bool Share::has_gpuid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Share::set_has_gpuid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Share::clear_has_gpuid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Share::clear_gpuid() {
  gpuid_ = 0u;
  clear_has_gpuid();
}
inline ::google::protobuf::uint32 Share::gpuid() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.gpuid)
  return gpuid_;
}
inline void Share::set_gpuid(::google::protobuf::uint32 value) {
  set_has_gpuid();
  gpuid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.gpuid)
}

// required string hash = 10;
inline bool Share::has_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Share::set_has_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Share::clear_has_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Share::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& Share::hash() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.hash)
  return hash_.GetNoArena();
}
inline void Share::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.hash)
}
#if LANG_CXX11
inline void Share::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.Share.hash)
}
#endif
inline void Share::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.hash)
}
inline void Share::set_hash(const char* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.hash)
}
inline ::std::string* Share::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_hash() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.hash)
  if (!has_hash()) {
    return NULL;
  }
  clear_has_hash();
  return hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.hash)
}

// required string merkle = 11;
inline bool Share::has_merkle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Share::set_has_merkle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Share::clear_has_merkle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Share::clear_merkle() {
  merkle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_merkle();
}
inline const ::std::string& Share::merkle() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.merkle)
  return merkle_.GetNoArena();
}
inline void Share::set_merkle(const ::std::string& value) {
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.merkle)
}
#if LANG_CXX11
inline void Share::set_merkle(::std::string&& value) {
  set_has_merkle();
  merkle_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.Share.merkle)
}
#endif
inline void Share::set_merkle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.merkle)
}
inline void Share::set_merkle(const char* value, size_t size) {
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.merkle)
}
inline ::std::string* Share::mutable_merkle() {
  set_has_merkle();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.merkle)
  return merkle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_merkle() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.merkle)
  if (!has_merkle()) {
    return NULL;
  }
  clear_has_merkle();
  return merkle_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_merkle(::std::string* merkle) {
  if (merkle != NULL) {
    set_has_merkle();
  } else {
    clear_has_merkle();
  }
  merkle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), merkle);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.merkle)
}

// required uint32 time = 12;
inline bool Share::has_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Share::set_has_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Share::clear_has_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Share::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 Share::time() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.time)
  return time_;
}
inline void Share::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.time)
}

// required uint32 bits = 13;
inline bool Share::has_bits() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Share::set_has_bits() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Share::clear_has_bits() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Share::clear_bits() {
  bits_ = 0u;
  clear_has_bits();
}
inline ::google::protobuf::uint32 Share::bits() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.bits)
  return bits_;
}
inline void Share::set_bits(::google::protobuf::uint32 value) {
  set_has_bits();
  bits_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.bits)
}

// required uint32 nonce = 14;
inline bool Share::has_nonce() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Share::set_has_nonce() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Share::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Share::clear_nonce() {
  nonce_ = 0u;
  clear_has_nonce();
}
inline ::google::protobuf::uint32 Share::nonce() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.nonce)
  return nonce_;
}
inline void Share::set_nonce(::google::protobuf::uint32 value) {
  set_has_nonce();
  nonce_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.nonce)
}

// required string multi = 15;
inline bool Share::has_multi() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Share::set_has_multi() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Share::clear_has_multi() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Share::clear_multi() {
  multi_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_multi();
}
inline const ::std::string& Share::multi() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.multi)
  return multi_.GetNoArena();
}
inline void Share::set_multi(const ::std::string& value) {
  set_has_multi();
  multi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.multi)
}
#if LANG_CXX11
inline void Share::set_multi(::std::string&& value) {
  set_has_multi();
  multi_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.Share.multi)
}
#endif
inline void Share::set_multi(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_multi();
  multi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.multi)
}
inline void Share::set_multi(const char* value, size_t size) {
  set_has_multi();
  multi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.multi)
}
inline ::std::string* Share::mutable_multi() {
  set_has_multi();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.multi)
  return multi_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_multi() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.multi)
  if (!has_multi()) {
    return NULL;
  }
  clear_has_multi();
  return multi_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_multi(::std::string* multi) {
  if (multi != NULL) {
    set_has_multi();
  } else {
    clear_has_multi();
  }
  multi_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), multi);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.multi)
}

// optional string blockhash = 16;
inline bool Share::has_blockhash() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Share::set_has_blockhash() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Share::clear_has_blockhash() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Share::clear_blockhash() {
  blockhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_blockhash();
}
inline const ::std::string& Share::blockhash() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.blockhash)
  return blockhash_.GetNoArena();
}
inline void Share::set_blockhash(const ::std::string& value) {
  set_has_blockhash();
  blockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Share.blockhash)
}
#if LANG_CXX11
inline void Share::set_blockhash(::std::string&& value) {
  set_has_blockhash();
  blockhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.Share.blockhash)
}
#endif
inline void Share::set_blockhash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_blockhash();
  blockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Share.blockhash)
}
inline void Share::set_blockhash(const char* value, size_t size) {
  set_has_blockhash();
  blockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Share.blockhash)
}
inline ::std::string* Share::mutable_blockhash() {
  set_has_blockhash();
  // @@protoc_insertion_point(field_mutable:pool.proto.Share.blockhash)
  return blockhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Share::release_blockhash() {
  // @@protoc_insertion_point(field_release:pool.proto.Share.blockhash)
  if (!has_blockhash()) {
    return NULL;
  }
  clear_has_blockhash();
  return blockhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Share::set_allocated_blockhash(::std::string* blockhash) {
  if (blockhash != NULL) {
    set_has_blockhash();
  } else {
    clear_has_blockhash();
  }
  blockhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockhash);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Share.blockhash)
}

// required uint32 height = 20;
inline bool Share::has_height() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Share::set_has_height() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Share::clear_has_height() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Share::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Share::height() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.height)
  return height_;
}
inline void Share::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.height)
}

// required uint32 length = 21;
inline bool Share::has_length() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Share::set_has_length() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Share::clear_has_length() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Share::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 Share::length() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.length)
  return length_;
}
inline void Share::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.length)
}

// required uint32 chaintype = 22;
inline bool Share::has_chaintype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Share::set_has_chaintype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Share::clear_has_chaintype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Share::clear_chaintype() {
  chaintype_ = 0u;
  clear_has_chaintype();
}
inline ::google::protobuf::uint32 Share::chaintype() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.chaintype)
  return chaintype_;
}
inline void Share::set_chaintype(::google::protobuf::uint32 value) {
  set_has_chaintype();
  chaintype_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.chaintype)
}

// required bool isblock = 23;
inline bool Share::has_isblock() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Share::set_has_isblock() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Share::clear_has_isblock() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Share::clear_isblock() {
  isblock_ = false;
  clear_has_isblock();
}
inline bool Share::isblock() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.isblock)
  return isblock_;
}
inline void Share::set_isblock(bool value) {
  set_has_isblock();
  isblock_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.isblock)
}

// optional uint64 genvalue = 24;
inline bool Share::has_genvalue() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Share::set_has_genvalue() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Share::clear_has_genvalue() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Share::clear_genvalue() {
  genvalue_ = GOOGLE_ULONGLONG(0);
  clear_has_genvalue();
}
inline ::google::protobuf::uint64 Share::genvalue() const {
  // @@protoc_insertion_point(field_get:pool.proto.Share.genvalue)
  return genvalue_;
}
inline void Share::set_genvalue(::google::protobuf::uint64 value) {
  set_has_genvalue();
  genvalue_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Share.genvalue)
}

// -------------------------------------------------------------------

// Request

// required .pool.proto.Request.Type type = 1;
inline bool Request::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pool::proto::Request_Type Request::type() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.type)
  return static_cast< ::pool::proto::Request_Type >(type_);
}
inline void Request::set_type(::pool::proto::Request_Type value) {
  assert(::pool::proto::Request_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Request.type)
}

// required uint32 reqid = 2;
inline bool Request::has_reqid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_reqid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_reqid() {
  reqid_ = 0u;
  clear_has_reqid();
}
inline ::google::protobuf::uint32 Request::reqid() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.reqid)
  return reqid_;
}
inline void Request::set_reqid(::google::protobuf::uint32 value) {
  set_has_reqid();
  reqid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Request.reqid)
}

// optional uint32 version = 10;
inline bool Request::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Request::version() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.version)
  return version_;
}
inline void Request::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Request.version)
}

// optional uint32 height = 11;
inline bool Request::has_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Request::height() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.height)
  return height_;
}
inline void Request::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Request.height)
}

// optional bytes reqnonce = 12;
inline bool Request::has_reqnonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_reqnonce() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_reqnonce() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_reqnonce() {
  reqnonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reqnonce();
}
inline const ::std::string& Request::reqnonce() const {
  // @@protoc_insertion_point(field_get:pool.proto.Request.reqnonce)
  return reqnonce_.GetNoArena();
}
inline void Request::set_reqnonce(const ::std::string& value) {
  set_has_reqnonce();
  reqnonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Request.reqnonce)
}
#if LANG_CXX11
inline void Request::set_reqnonce(::std::string&& value) {
  set_has_reqnonce();
  reqnonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.Request.reqnonce)
}
#endif
inline void Request::set_reqnonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reqnonce();
  reqnonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Request.reqnonce)
}
inline void Request::set_reqnonce(const void* value, size_t size) {
  set_has_reqnonce();
  reqnonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Request.reqnonce)
}
inline ::std::string* Request::mutable_reqnonce() {
  set_has_reqnonce();
  // @@protoc_insertion_point(field_mutable:pool.proto.Request.reqnonce)
  return reqnonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_reqnonce() {
  // @@protoc_insertion_point(field_release:pool.proto.Request.reqnonce)
  if (!has_reqnonce()) {
    return NULL;
  }
  clear_has_reqnonce();
  return reqnonce_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_reqnonce(::std::string* reqnonce) {
  if (reqnonce != NULL) {
    set_has_reqnonce();
  } else {
    clear_has_reqnonce();
  }
  reqnonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reqnonce);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Request.reqnonce)
}

// optional .pool.proto.Share share = 20;
inline bool Request::has_share() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_share() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_share() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_share() {
  if (share_ != NULL) share_->Clear();
  clear_has_share();
}
inline const ::pool::proto::Share& Request::_internal_share() const {
  return *share_;
}
inline const ::pool::proto::Share& Request::share() const {
  const ::pool::proto::Share* p = share_;
  // @@protoc_insertion_point(field_get:pool.proto.Request.share)
  return p != NULL ? *p : *reinterpret_cast<const ::pool::proto::Share*>(
      &::pool::proto::_Share_default_instance_);
}
inline ::pool::proto::Share* Request::release_share() {
  // @@protoc_insertion_point(field_release:pool.proto.Request.share)
  clear_has_share();
  ::pool::proto::Share* temp = share_;
  share_ = NULL;
  return temp;
}
inline ::pool::proto::Share* Request::mutable_share() {
  set_has_share();
  if (share_ == NULL) {
    auto* p = CreateMaybeMessage<::pool::proto::Share>(GetArenaNoVirtual());
    share_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Request.share)
  return share_;
}
inline void Request::set_allocated_share(::pool::proto::Share* share) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete share_;
  }
  if (share) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      share = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, share, submessage_arena);
    }
    set_has_share();
  } else {
    clear_has_share();
  }
  share_ = share;
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Request.share)
}

// optional .pool.proto.ClientStats stats = 21;
inline bool Request::has_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_stats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_stats() {
  if (stats_ != NULL) stats_->Clear();
  clear_has_stats();
}
inline const ::pool::proto::ClientStats& Request::_internal_stats() const {
  return *stats_;
}
inline const ::pool::proto::ClientStats& Request::stats() const {
  const ::pool::proto::ClientStats* p = stats_;
  // @@protoc_insertion_point(field_get:pool.proto.Request.stats)
  return p != NULL ? *p : *reinterpret_cast<const ::pool::proto::ClientStats*>(
      &::pool::proto::_ClientStats_default_instance_);
}
inline ::pool::proto::ClientStats* Request::release_stats() {
  // @@protoc_insertion_point(field_release:pool.proto.Request.stats)
  clear_has_stats();
  ::pool::proto::ClientStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline ::pool::proto::ClientStats* Request::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) {
    auto* p = CreateMaybeMessage<::pool::proto::ClientStats>(GetArenaNoVirtual());
    stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Request.stats)
  return stats_;
}
inline void Request::set_allocated_stats(::pool::proto::ClientStats* stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_;
  }
  if (stats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    set_has_stats();
  } else {
    clear_has_stats();
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Request.stats)
}

// -------------------------------------------------------------------

// ServerInfo

// required string host = 1;
inline bool ServerInfo::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfo::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfo::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfo::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& ServerInfo::host() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerInfo.host)
  return host_.GetNoArena();
}
inline void ServerInfo::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.ServerInfo.host)
}
#if LANG_CXX11
inline void ServerInfo::set_host(::std::string&& value) {
  set_has_host();
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.ServerInfo.host)
}
#endif
inline void ServerInfo::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.ServerInfo.host)
}
inline void ServerInfo::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.ServerInfo.host)
}
inline ::std::string* ServerInfo::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:pool.proto.ServerInfo.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerInfo::release_host() {
  // @@protoc_insertion_point(field_release:pool.proto.ServerInfo.host)
  if (!has_host()) {
    return NULL;
  }
  clear_has_host();
  return host_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInfo::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.ServerInfo.host)
}

// required uint32 router = 2;
inline bool ServerInfo::has_router() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfo::set_has_router() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfo::clear_has_router() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfo::clear_router() {
  router_ = 0u;
  clear_has_router();
}
inline ::google::protobuf::uint32 ServerInfo::router() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerInfo.router)
  return router_;
}
inline void ServerInfo::set_router(::google::protobuf::uint32 value) {
  set_has_router();
  router_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerInfo.router)
}

// required uint32 pub = 3;
inline bool ServerInfo::has_pub() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerInfo::set_has_pub() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerInfo::clear_has_pub() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerInfo::clear_pub() {
  pub_ = 0u;
  clear_has_pub();
}
inline ::google::protobuf::uint32 ServerInfo::pub() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerInfo.pub)
  return pub_;
}
inline void ServerInfo::set_pub(::google::protobuf::uint32 value) {
  set_has_pub();
  pub_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerInfo.pub)
}

// required uint32 target = 4;
inline bool ServerInfo::has_target() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerInfo::set_has_target() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerInfo::clear_has_target() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerInfo::clear_target() {
  target_ = 0u;
  clear_has_target();
}
inline ::google::protobuf::uint32 ServerInfo::target() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerInfo.target)
  return target_;
}
inline void ServerInfo::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerInfo.target)
}

// -------------------------------------------------------------------

// Work

// required uint32 height = 1;
inline bool Work::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Work::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Work::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Work::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Work::height() const {
  // @@protoc_insertion_point(field_get:pool.proto.Work.height)
  return height_;
}
inline void Work::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Work.height)
}

// required string merkle = 2;
inline bool Work::has_merkle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Work::set_has_merkle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Work::clear_has_merkle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Work::clear_merkle() {
  merkle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_merkle();
}
inline const ::std::string& Work::merkle() const {
  // @@protoc_insertion_point(field_get:pool.proto.Work.merkle)
  return merkle_.GetNoArena();
}
inline void Work::set_merkle(const ::std::string& value) {
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Work.merkle)
}
#if LANG_CXX11
inline void Work::set_merkle(::std::string&& value) {
  set_has_merkle();
  merkle_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.Work.merkle)
}
#endif
inline void Work::set_merkle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Work.merkle)
}
inline void Work::set_merkle(const char* value, size_t size) {
  set_has_merkle();
  merkle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Work.merkle)
}
inline ::std::string* Work::mutable_merkle() {
  set_has_merkle();
  // @@protoc_insertion_point(field_mutable:pool.proto.Work.merkle)
  return merkle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Work::release_merkle() {
  // @@protoc_insertion_point(field_release:pool.proto.Work.merkle)
  if (!has_merkle()) {
    return NULL;
  }
  clear_has_merkle();
  return merkle_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Work::set_allocated_merkle(::std::string* merkle) {
  if (merkle != NULL) {
    set_has_merkle();
  } else {
    clear_has_merkle();
  }
  merkle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), merkle);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Work.merkle)
}

// required uint32 time = 3;
inline bool Work::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Work::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Work::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Work::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 Work::time() const {
  // @@protoc_insertion_point(field_get:pool.proto.Work.time)
  return time_;
}
inline void Work::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Work.time)
}

// required uint32 bits = 4;
inline bool Work::has_bits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Work::set_has_bits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Work::clear_has_bits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Work::clear_bits() {
  bits_ = 0u;
  clear_has_bits();
}
inline ::google::protobuf::uint32 Work::bits() const {
  // @@protoc_insertion_point(field_get:pool.proto.Work.bits)
  return bits_;
}
inline void Work::set_bits(::google::protobuf::uint32 value) {
  set_has_bits();
  bits_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Work.bits)
}

// -------------------------------------------------------------------

// Reply

// required .pool.proto.Request.Type type = 1;
inline bool Reply::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Reply::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Reply::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Reply::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pool::proto::Request_Type Reply::type() const {
  // @@protoc_insertion_point(field_get:pool.proto.Reply.type)
  return static_cast< ::pool::proto::Request_Type >(type_);
}
inline void Reply::set_type(::pool::proto::Request_Type value) {
  assert(::pool::proto::Request_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Reply.type)
}

// required uint32 reqid = 2;
inline bool Reply::has_reqid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Reply::set_has_reqid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Reply::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Reply::clear_reqid() {
  reqid_ = 0u;
  clear_has_reqid();
}
inline ::google::protobuf::uint32 Reply::reqid() const {
  // @@protoc_insertion_point(field_get:pool.proto.Reply.reqid)
  return reqid_;
}
inline void Reply::set_reqid(::google::protobuf::uint32 value) {
  set_has_reqid();
  reqid_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Reply.reqid)
}

// required .pool.proto.Reply.ErrType error = 10;
inline bool Reply::has_error() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Reply::set_has_error() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Reply::clear_has_error() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Reply::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::pool::proto::Reply_ErrType Reply::error() const {
  // @@protoc_insertion_point(field_get:pool.proto.Reply.error)
  return static_cast< ::pool::proto::Reply_ErrType >(error_);
}
inline void Reply::set_error(::pool::proto::Reply_ErrType value) {
  assert(::pool::proto::Reply_ErrType_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.Reply.error)
}

// optional string errstr = 11;
inline bool Reply::has_errstr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reply::set_has_errstr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reply::clear_has_errstr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reply::clear_errstr() {
  errstr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errstr();
}
inline const ::std::string& Reply::errstr() const {
  // @@protoc_insertion_point(field_get:pool.proto.Reply.errstr)
  return errstr_.GetNoArena();
}
inline void Reply::set_errstr(const ::std::string& value) {
  set_has_errstr();
  errstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.Reply.errstr)
}
#if LANG_CXX11
inline void Reply::set_errstr(::std::string&& value) {
  set_has_errstr();
  errstr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.Reply.errstr)
}
#endif
inline void Reply::set_errstr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errstr();
  errstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.Reply.errstr)
}
inline void Reply::set_errstr(const char* value, size_t size) {
  set_has_errstr();
  errstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.Reply.errstr)
}
inline ::std::string* Reply::mutable_errstr() {
  set_has_errstr();
  // @@protoc_insertion_point(field_mutable:pool.proto.Reply.errstr)
  return errstr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Reply::release_errstr() {
  // @@protoc_insertion_point(field_release:pool.proto.Reply.errstr)
  if (!has_errstr()) {
    return NULL;
  }
  clear_has_errstr();
  return errstr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reply::set_allocated_errstr(::std::string* errstr) {
  if (errstr != NULL) {
    set_has_errstr();
  } else {
    clear_has_errstr();
  }
  errstr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errstr);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Reply.errstr)
}

// optional .pool.proto.ServerInfo sinfo = 20;
inline bool Reply::has_sinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reply::set_has_sinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reply::clear_has_sinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reply::clear_sinfo() {
  if (sinfo_ != NULL) sinfo_->Clear();
  clear_has_sinfo();
}
inline const ::pool::proto::ServerInfo& Reply::_internal_sinfo() const {
  return *sinfo_;
}
inline const ::pool::proto::ServerInfo& Reply::sinfo() const {
  const ::pool::proto::ServerInfo* p = sinfo_;
  // @@protoc_insertion_point(field_get:pool.proto.Reply.sinfo)
  return p != NULL ? *p : *reinterpret_cast<const ::pool::proto::ServerInfo*>(
      &::pool::proto::_ServerInfo_default_instance_);
}
inline ::pool::proto::ServerInfo* Reply::release_sinfo() {
  // @@protoc_insertion_point(field_release:pool.proto.Reply.sinfo)
  clear_has_sinfo();
  ::pool::proto::ServerInfo* temp = sinfo_;
  sinfo_ = NULL;
  return temp;
}
inline ::pool::proto::ServerInfo* Reply::mutable_sinfo() {
  set_has_sinfo();
  if (sinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::pool::proto::ServerInfo>(GetArenaNoVirtual());
    sinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Reply.sinfo)
  return sinfo_;
}
inline void Reply::set_allocated_sinfo(::pool::proto::ServerInfo* sinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sinfo_;
  }
  if (sinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sinfo, submessage_arena);
    }
    set_has_sinfo();
  } else {
    clear_has_sinfo();
  }
  sinfo_ = sinfo;
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Reply.sinfo)
}

// optional .pool.proto.Work work = 21;
inline bool Reply::has_work() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reply::set_has_work() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reply::clear_has_work() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reply::clear_work() {
  if (work_ != NULL) work_->Clear();
  clear_has_work();
}
inline const ::pool::proto::Work& Reply::_internal_work() const {
  return *work_;
}
inline const ::pool::proto::Work& Reply::work() const {
  const ::pool::proto::Work* p = work_;
  // @@protoc_insertion_point(field_get:pool.proto.Reply.work)
  return p != NULL ? *p : *reinterpret_cast<const ::pool::proto::Work*>(
      &::pool::proto::_Work_default_instance_);
}
inline ::pool::proto::Work* Reply::release_work() {
  // @@protoc_insertion_point(field_release:pool.proto.Reply.work)
  clear_has_work();
  ::pool::proto::Work* temp = work_;
  work_ = NULL;
  return temp;
}
inline ::pool::proto::Work* Reply::mutable_work() {
  set_has_work();
  if (work_ == NULL) {
    auto* p = CreateMaybeMessage<::pool::proto::Work>(GetArenaNoVirtual());
    work_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Reply.work)
  return work_;
}
inline void Reply::set_allocated_work(::pool::proto::Work* work) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete work_;
  }
  if (work) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      work = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, work, submessage_arena);
    }
    set_has_work();
  } else {
    clear_has_work();
  }
  work_ = work;
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Reply.work)
}

// optional .pool.proto.Block block = 22;
inline bool Reply::has_block() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reply::set_has_block() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reply::clear_has_block() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reply::clear_block() {
  if (block_ != NULL) block_->Clear();
  clear_has_block();
}
inline const ::pool::proto::Block& Reply::_internal_block() const {
  return *block_;
}
inline const ::pool::proto::Block& Reply::block() const {
  const ::pool::proto::Block* p = block_;
  // @@protoc_insertion_point(field_get:pool.proto.Reply.block)
  return p != NULL ? *p : *reinterpret_cast<const ::pool::proto::Block*>(
      &::pool::proto::_Block_default_instance_);
}
inline ::pool::proto::Block* Reply::release_block() {
  // @@protoc_insertion_point(field_release:pool.proto.Reply.block)
  clear_has_block();
  ::pool::proto::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline ::pool::proto::Block* Reply::mutable_block() {
  set_has_block();
  if (block_ == NULL) {
    auto* p = CreateMaybeMessage<::pool::proto::Block>(GetArenaNoVirtual());
    block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Reply.block)
  return block_;
}
inline void Reply::set_allocated_block(::pool::proto::Block* block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete block_;
  }
  if (block) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    set_has_block();
  } else {
    clear_has_block();
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Reply.block)
}

// -------------------------------------------------------------------

// ReqStats

// required .pool.proto.Request.Type reqtype = 1;
inline bool ReqStats::has_reqtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqStats::set_has_reqtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqStats::clear_has_reqtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqStats::clear_reqtype() {
  reqtype_ = 0;
  clear_has_reqtype();
}
inline ::pool::proto::Request_Type ReqStats::reqtype() const {
  // @@protoc_insertion_point(field_get:pool.proto.ReqStats.reqtype)
  return static_cast< ::pool::proto::Request_Type >(reqtype_);
}
inline void ReqStats::set_reqtype(::pool::proto::Request_Type value) {
  assert(::pool::proto::Request_Type_IsValid(value));
  set_has_reqtype();
  reqtype_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ReqStats.reqtype)
}

// required .pool.proto.Reply.ErrType errtype = 2;
inline bool ReqStats::has_errtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqStats::set_has_errtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqStats::clear_has_errtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqStats::clear_errtype() {
  errtype_ = 0;
  clear_has_errtype();
}
inline ::pool::proto::Reply_ErrType ReqStats::errtype() const {
  // @@protoc_insertion_point(field_get:pool.proto.ReqStats.errtype)
  return static_cast< ::pool::proto::Reply_ErrType >(errtype_);
}
inline void ReqStats::set_errtype(::pool::proto::Reply_ErrType value) {
  assert(::pool::proto::Reply_ErrType_IsValid(value));
  set_has_errtype();
  errtype_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ReqStats.errtype)
}

// required uint32 count = 3;
inline bool ReqStats::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqStats::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqStats::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqStats::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 ReqStats::count() const {
  // @@protoc_insertion_point(field_get:pool.proto.ReqStats.count)
  return count_;
}
inline void ReqStats::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ReqStats.count)
}

// -------------------------------------------------------------------

// ServerStats

// required string name = 1;
inline bool ServerStats::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerStats::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerStats::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerStats::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ServerStats::name() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.name)
  return name_.GetNoArena();
}
inline void ServerStats::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pool.proto.ServerStats.name)
}
#if LANG_CXX11
inline void ServerStats::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pool.proto.ServerStats.name)
}
#endif
inline void ServerStats::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pool.proto.ServerStats.name)
}
inline void ServerStats::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pool.proto.ServerStats.name)
}
inline ::std::string* ServerStats::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:pool.proto.ServerStats.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerStats::release_name() {
  // @@protoc_insertion_point(field_release:pool.proto.ServerStats.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerStats::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pool.proto.ServerStats.name)
}

// required uint32 thread = 2;
inline bool ServerStats::has_thread() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerStats::set_has_thread() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerStats::clear_has_thread() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerStats::clear_thread() {
  thread_ = 0u;
  clear_has_thread();
}
inline ::google::protobuf::uint32 ServerStats::thread() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.thread)
  return thread_;
}
inline void ServerStats::set_thread(::google::protobuf::uint32 value) {
  set_has_thread();
  thread_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerStats.thread)
}

// required uint32 workers = 10;
inline bool ServerStats::has_workers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerStats::set_has_workers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerStats::clear_has_workers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerStats::clear_workers() {
  workers_ = 0u;
  clear_has_workers();
}
inline ::google::protobuf::uint32 ServerStats::workers() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.workers)
  return workers_;
}
inline void ServerStats::set_workers(::google::protobuf::uint32 value) {
  set_has_workers();
  workers_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerStats.workers)
}

// required uint32 latency = 11;
inline bool ServerStats::has_latency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerStats::set_has_latency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerStats::clear_has_latency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerStats::clear_latency() {
  latency_ = 0u;
  clear_has_latency();
}
inline ::google::protobuf::uint32 ServerStats::latency() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.latency)
  return latency_;
}
inline void ServerStats::set_latency(::google::protobuf::uint32 value) {
  set_has_latency();
  latency_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerStats.latency)
}

// required float cpd = 12;
inline bool ServerStats::has_cpd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerStats::set_has_cpd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerStats::clear_has_cpd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerStats::clear_cpd() {
  cpd_ = 0;
  clear_has_cpd();
}
inline float ServerStats::cpd() const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.cpd)
  return cpd_;
}
inline void ServerStats::set_cpd(float value) {
  set_has_cpd();
  cpd_ = value;
  // @@protoc_insertion_point(field_set:pool.proto.ServerStats.cpd)
}

// repeated .pool.proto.ReqStats reqstats = 20;
inline int ServerStats::reqstats_size() const {
  return reqstats_.size();
}
inline void ServerStats::clear_reqstats() {
  reqstats_.Clear();
}
inline ::pool::proto::ReqStats* ServerStats::mutable_reqstats(int index) {
  // @@protoc_insertion_point(field_mutable:pool.proto.ServerStats.reqstats)
  return reqstats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >*
ServerStats::mutable_reqstats() {
  // @@protoc_insertion_point(field_mutable_list:pool.proto.ServerStats.reqstats)
  return &reqstats_;
}
inline const ::pool::proto::ReqStats& ServerStats::reqstats(int index) const {
  // @@protoc_insertion_point(field_get:pool.proto.ServerStats.reqstats)
  return reqstats_.Get(index);
}
inline ::pool::proto::ReqStats* ServerStats::add_reqstats() {
  // @@protoc_insertion_point(field_add:pool.proto.ServerStats.reqstats)
  return reqstats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pool::proto::ReqStats >&
ServerStats::reqstats() const {
  // @@protoc_insertion_point(field_list:pool.proto.ServerStats.reqstats)
  return reqstats_;
}

// -------------------------------------------------------------------

// Data

// optional .pool.proto.Share share = 1;
inline bool Data::has_share() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data::set_has_share() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data::clear_has_share() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data::clear_share() {
  if (share_ != NULL) share_->Clear();
  clear_has_share();
}
inline const ::pool::proto::Share& Data::_internal_share() const {
  return *share_;
}
inline const ::pool::proto::Share& Data::share() const {
  const ::pool::proto::Share* p = share_;
  // @@protoc_insertion_point(field_get:pool.proto.Data.share)
  return p != NULL ? *p : *reinterpret_cast<const ::pool::proto::Share*>(
      &::pool::proto::_Share_default_instance_);
}
inline ::pool::proto::Share* Data::release_share() {
  // @@protoc_insertion_point(field_release:pool.proto.Data.share)
  clear_has_share();
  ::pool::proto::Share* temp = share_;
  share_ = NULL;
  return temp;
}
inline ::pool::proto::Share* Data::mutable_share() {
  set_has_share();
  if (share_ == NULL) {
    auto* p = CreateMaybeMessage<::pool::proto::Share>(GetArenaNoVirtual());
    share_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Data.share)
  return share_;
}
inline void Data::set_allocated_share(::pool::proto::Share* share) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete share_;
  }
  if (share) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      share = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, share, submessage_arena);
    }
    set_has_share();
  } else {
    clear_has_share();
  }
  share_ = share;
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Data.share)
}

// optional .pool.proto.ClientStats clientstats = 2;
inline bool Data::has_clientstats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data::set_has_clientstats() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data::clear_has_clientstats() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data::clear_clientstats() {
  if (clientstats_ != NULL) clientstats_->Clear();
  clear_has_clientstats();
}
inline const ::pool::proto::ClientStats& Data::_internal_clientstats() const {
  return *clientstats_;
}
inline const ::pool::proto::ClientStats& Data::clientstats() const {
  const ::pool::proto::ClientStats* p = clientstats_;
  // @@protoc_insertion_point(field_get:pool.proto.Data.clientstats)
  return p != NULL ? *p : *reinterpret_cast<const ::pool::proto::ClientStats*>(
      &::pool::proto::_ClientStats_default_instance_);
}
inline ::pool::proto::ClientStats* Data::release_clientstats() {
  // @@protoc_insertion_point(field_release:pool.proto.Data.clientstats)
  clear_has_clientstats();
  ::pool::proto::ClientStats* temp = clientstats_;
  clientstats_ = NULL;
  return temp;
}
inline ::pool::proto::ClientStats* Data::mutable_clientstats() {
  set_has_clientstats();
  if (clientstats_ == NULL) {
    auto* p = CreateMaybeMessage<::pool::proto::ClientStats>(GetArenaNoVirtual());
    clientstats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Data.clientstats)
  return clientstats_;
}
inline void Data::set_allocated_clientstats(::pool::proto::ClientStats* clientstats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete clientstats_;
  }
  if (clientstats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      clientstats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, clientstats, submessage_arena);
    }
    set_has_clientstats();
  } else {
    clear_has_clientstats();
  }
  clientstats_ = clientstats;
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Data.clientstats)
}

// optional .pool.proto.ServerStats serverstats = 3;
inline bool Data::has_serverstats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Data::set_has_serverstats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Data::clear_has_serverstats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Data::clear_serverstats() {
  if (serverstats_ != NULL) serverstats_->Clear();
  clear_has_serverstats();
}
inline const ::pool::proto::ServerStats& Data::_internal_serverstats() const {
  return *serverstats_;
}
inline const ::pool::proto::ServerStats& Data::serverstats() const {
  const ::pool::proto::ServerStats* p = serverstats_;
  // @@protoc_insertion_point(field_get:pool.proto.Data.serverstats)
  return p != NULL ? *p : *reinterpret_cast<const ::pool::proto::ServerStats*>(
      &::pool::proto::_ServerStats_default_instance_);
}
inline ::pool::proto::ServerStats* Data::release_serverstats() {
  // @@protoc_insertion_point(field_release:pool.proto.Data.serverstats)
  clear_has_serverstats();
  ::pool::proto::ServerStats* temp = serverstats_;
  serverstats_ = NULL;
  return temp;
}
inline ::pool::proto::ServerStats* Data::mutable_serverstats() {
  set_has_serverstats();
  if (serverstats_ == NULL) {
    auto* p = CreateMaybeMessage<::pool::proto::ServerStats>(GetArenaNoVirtual());
    serverstats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pool.proto.Data.serverstats)
  return serverstats_;
}
inline void Data::set_allocated_serverstats(::pool::proto::ServerStats* serverstats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete serverstats_;
  }
  if (serverstats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      serverstats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, serverstats, submessage_arena);
    }
    set_has_serverstats();
  } else {
    clear_has_serverstats();
  }
  serverstats_ = serverstats;
  // @@protoc_insertion_point(field_set_allocated:pool.proto.Data.serverstats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace pool

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pool::proto::Signal_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pool::proto::Signal_Type>() {
  return ::pool::proto::Signal_Type_descriptor();
}
template <> struct is_proto_enum< ::pool::proto::Request_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pool::proto::Request_Type>() {
  return ::pool::proto::Request_Type_descriptor();
}
template <> struct is_proto_enum< ::pool::proto::Reply_ErrType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pool::proto::Reply_ErrType>() {
  return ::pool::proto::Reply_ErrType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protocol_2eproto
